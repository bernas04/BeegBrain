"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.addPackageToPkgJson = exports.getPropertyFromWorkspace = exports.propertyExistsInWorkspace = exports.addDependencies = exports.logSuccess = exports.overwriteJsonFile = exports.getConfigFile = exports.getWorkspacePath = exports.DEPENDENCIES_MAP = exports.PackageTarget = void 0;
const core_1 = require("@angular-devkit/core");
const util_1 = require("./util");
var PackageTarget;
(function (PackageTarget) {
    PackageTarget["DEV"] = "devDependencies";
    PackageTarget["REGULAR"] = "dependencies";
    PackageTarget["NONE"] = "none";
})(PackageTarget = exports.PackageTarget || (exports.PackageTarget = {}));
const schematicsPackage = '@igniteui/angular-schematics';
/**
 * Dependencies are explicitly defined here, so we avoid adding
 * unnecessary packages to the consuming project's deps
 */
exports.DEPENDENCIES_MAP = [
    // dependencies
    { name: 'hammerjs', target: PackageTarget.REGULAR },
    { name: 'jszip', target: PackageTarget.REGULAR },
    { name: 'tslib', target: PackageTarget.NONE },
    { name: '@types/hammerjs', target: PackageTarget.DEV },
    { name: 'igniteui-trial-watermark', target: PackageTarget.NONE },
    { name: 'lodash.mergewith', target: PackageTarget.NONE },
    { name: 'uuid', target: PackageTarget.NONE },
    { name: '@igniteui/material-icons-extended', target: PackageTarget.REGULAR },
    // peerDependencies
    { name: '@angular/forms', target: PackageTarget.NONE },
    { name: '@angular/common', target: PackageTarget.NONE },
    { name: '@angular/core', target: PackageTarget.NONE },
    { name: '@angular/animations', target: PackageTarget.NONE },
    // igxDevDependencies
    { name: '@igniteui/angular-schematics', target: PackageTarget.DEV }
];
const getWorkspacePath = (host) => {
    const targetFiles = ['/angular.json', '/.angular.json'];
    return targetFiles.filter(p => host.exists(p))[0];
};
exports.getWorkspacePath = getWorkspacePath;
const logIncludingDependency = (context, pkg, version) => context.logger.info(`Including ${pkg} - Version: ${version}`);
const getTargetedProjectOptions = (project, target, context) => {
    var _a;
    if (project.targets &&
        project.targets[target] &&
        project.targets[target].options) {
        return project.targets[target].options;
    }
    const projectTarget = (_a = project.targets) === null || _a === void 0 ? void 0 : _a.get(target);
    if (projectTarget) {
        return projectTarget.options;
    }
    context.logger.warn(`Could not find matching ${target} options ` +
        `in Angular workspace ${project.sourceRoot}. ` +
        `It could require you to manually add and update the ${target} section.`);
};
const getConfigFile = (project, option, context, configSection = 'build') => {
    const options = getTargetedProjectOptions(project, configSection, context);
    if (!options) {
        context.logger.warn(`Could not find matching ${configSection} options in Angular workspace. ` +
            `It could require you to manually add and update the ${configSection} options.`);
    }
    if (options) {
        if (!options[option]) {
            context.logger.warn(`Could not find a matching ${option} property under ${configSection} options in Angular workspace. ` +
                `Some updates may not execute correctly.`);
        }
        else {
            return options[option];
        }
    }
};
exports.getConfigFile = getConfigFile;
const overwriteJsonFile = (tree, targetFile, data) => tree.overwrite(targetFile, JSON.stringify(data, null, 2) + '\n');
exports.overwriteJsonFile = overwriteJsonFile;
// eslint-disable-next-line @typescript-eslint/no-unused-vars
const logSuccess = (options) => (tree, context) => {
    context.logger.info('');
    context.logger.warn('Ignite UI for Angular installed');
    context.logger.info('Learn more: https://www.infragistics.com/products/ignite-ui-angular');
    context.logger.info('');
};
exports.logSuccess = logSuccess;
// eslint-disable-next-line @typescript-eslint/no-unused-vars
const addDependencies = (options) => (tree, context) => __awaiter(void 0, void 0, void 0, function* () {
    const pkgJson = require('../../package.json');
    yield includeDependencies(pkgJson, context, tree);
    (0, exports.addPackageToPkgJson)(tree, schematicsPackage, pkgJson.igxDevDependencies[schematicsPackage], PackageTarget.DEV);
});
exports.addDependencies = addDependencies;
/** Checks whether a property exists in the angular workspace. */
const propertyExistsInWorkspace = (targetProp, workspace) => {
    const foundProp = (0, exports.getPropertyFromWorkspace)(targetProp, workspace);
    return foundProp !== null && foundProp.key === targetProp;
};
exports.propertyExistsInWorkspace = propertyExistsInWorkspace;
/** Recursively search for the first property that matches targetProp within a json file. */
const getPropertyFromWorkspace = (targetProp, workspace, curKey = '') => {
    if (workspace.hasOwnProperty(targetProp)) {
        return { key: targetProp, value: workspace[targetProp] };
    }
    const workspaceKeys = Object.keys(workspace);
    for (const key of workspaceKeys) {
        // If the target property is an array, return its key and its contents.
        if (Array.isArray(workspace[key])) {
            return {
                key: curKey,
                value: workspace[key]
            };
        }
        else if (workspace[key] instanceof Object) {
            // If the target property is an object, go one level in.
            if (workspace.hasOwnProperty(key)) {
                const newValue = (0, exports.getPropertyFromWorkspace)(targetProp, workspace[key], key);
                if (newValue) {
                    return newValue;
                }
            }
        }
    }
    return null;
};
exports.getPropertyFromWorkspace = getPropertyFromWorkspace;
const addHammerToConfig = (project, tree, config, context) => __awaiter(void 0, void 0, void 0, function* () {
    var _a, _b;
    const projectOptions = getTargetedProjectOptions(project, config, context);
    const tsPath = (0, exports.getConfigFile)(project, 'main', context, config);
    const hammerImport = 'import \'hammerjs\';\n';
    const tsContent = (_a = tree.read(tsPath)) === null || _a === void 0 ? void 0 : _a.toString();
    // if there are no elements in the architect[config]options.scripts array that contain hammerjs
    // and the "main" file does not contain an import with hammerjs
    if (!((_b = projectOptions === null || projectOptions === void 0 ? void 0 : projectOptions.scripts) === null || _b === void 0 ? void 0 : _b.some(el => el.includes('hammerjs'))) && !(tsContent === null || tsContent === void 0 ? void 0 : tsContent.includes(hammerImport))) {
        const hammerjsFilePath = './node_modules/hammerjs/hammer.min.js';
        if (projectOptions === null || projectOptions === void 0 ? void 0 : projectOptions.scripts) {
            projectOptions.scripts.push(hammerjsFilePath);
            return;
        }
        context.logger.warn(`Could not find a matching scripts array property under ${config} options. ` +
            `It could require you to manually update it to 'scripts': [ ${hammerjsFilePath}] `);
    }
});
const includeDependencies = (pkgJson, context, tree) => __awaiter(void 0, void 0, void 0, function* () {
    const workspaceHost = (0, util_1.createHost)(tree);
    const { workspace } = yield core_1.workspaces.readWorkspace(tree.root.path, workspaceHost);
    const defaultProject = workspace.projects.get(workspace.extensions['defaultProject']);
    for (const pkg of Object.keys(pkgJson.dependencies)) {
        const version = pkgJson.dependencies[pkg];
        const entry = exports.DEPENDENCIES_MAP.find(e => e.name === pkg);
        if (!entry || entry.target === PackageTarget.NONE) {
            continue;
        }
        switch (pkg) {
            case 'hammerjs':
                logIncludingDependency(context, pkg, version);
                (0, exports.addPackageToPkgJson)(tree, pkg, version, entry.target);
                yield addHammerToConfig(defaultProject, tree, 'build', context);
                yield addHammerToConfig(defaultProject, tree, 'test', context);
                break;
            default:
                logIncludingDependency(context, pkg, version);
                (0, exports.addPackageToPkgJson)(tree, pkg, version, entry.target);
                break;
        }
    }
    yield core_1.workspaces.writeWorkspace(workspace, workspaceHost);
});
const addPackageToPkgJson = (tree, pkg, version, target) => {
    const targetFile = 'package.json';
    if (tree.exists(targetFile)) {
        const sourceText = tree.read(targetFile).toString();
        const json = JSON.parse(sourceText);
        if (!json[target]) {
            json[target] = {};
        }
        if (!json.dependencies[pkg]) {
            json[target][pkg] = version;
            json[target] =
                Object.keys(json[target])
                    .sort()
                    .reduce((result, key) => (result[key] = json[target][key]) && result, {});
            tree.overwrite(targetFile, JSON.stringify(json, null, 2) + '\n');
        }
        return true;
    }
    return false;
};
exports.addPackageToPkgJson = addPackageToPkgJson;
