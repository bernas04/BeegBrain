"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.updateWorkspace = void 0;
const cli_core_1 = require("@igniteui/cli-core");
const path = require("path");
const package_resolve_1 = require("./package-resolve");
const styleExtension = ["css", "scss", "sass"];
var RegularExpressionType;
(function (RegularExpressionType) {
    RegularExpressionType[RegularExpressionType["STYLE"] = 0] = "STYLE";
    RegularExpressionType[RegularExpressionType["LOGIC"] = 1] = "LOGIC";
})(RegularExpressionType || (RegularExpressionType = {}));
function createExpression(expressionType, packageName) {
    if (expressionType === RegularExpressionType.LOGIC) {
        return String.raw `(from ["'])${packageName}(?<submodules>\/.*?)?(["'])`;
    }
    else if (expressionType === RegularExpressionType.STYLE) {
        return String.raw `(node_modules\/|[~"'])${packageName}(\/)`;
    }
}
function updateWorkspace(rootPath) {
    return __awaiter(this, void 0, void 0, function* () {
        const fs = cli_core_1.App.container.get(cli_core_1.FS_TOKEN);
        const upgradeable = (0, package_resolve_1.getUpgradeablePackages)();
        if (!upgradeable.length) {
            cli_core_1.Util.log("Your app is already using packages from the Infragistics registry. You are good to go.", "green");
            return false;
        }
        const packageJsonPath = path.join(rootPath, "package.json");
        const fileString = fs.readFile(packageJsonPath);
        // check for registry user in npm
        const config = cli_core_1.ProjectConfig.getConfig();
        if (!fileString) {
            cli_core_1.Util.log("Package.json not found!");
            return false;
        }
        const pkgJSON = JSON.parse(fileString);
        const errorMsg = "Something went wrong, " +
            "please follow the steps in this guide: https://www.infragistics.com/products/ignite-ui-angular/angular/components/general/ignite-ui-licensing";
        if (!cli_core_1.PackageManager.ensureRegistryUser(config, errorMsg)) {
            return false;
        }
        // get all workspace roots
        const workspaces = [];
        let workspaceConfig = null;
        const workspacePath = path.join(rootPath, "angular.json");
        if (fs.fileExists(workspacePath)) {
            workspaceConfig = JSON.parse(fs.readFile(workspacePath));
        }
        else {
            cli_core_1.Util.log("No angular.json file found! Aborting.");
            return false;
        }
        for (const entry of Object.keys(workspaceConfig.projects)) {
            if (workspaceConfig.projects[entry].sourceRoot) {
                // ignore projects without sourceRoot (likely older e2e proj)
                workspaces.push(path.join(rootPath, workspaceConfig.projects[entry].sourceRoot));
            }
        }
        // once all workspace are gotten, get all files for all workspaces
        const logicFiles = [];
        const styleFiles = [];
        for (const workspace of workspaces) {
            logicFiles.push(...fs.glob(workspace, "**/*.ts"));
            for (const extension of styleExtension) {
                styleFiles.push(...fs.glob(workspace, `**/*.${extension}`));
            }
        }
        styleFiles.push(workspacePath);
        for (const packageDef of upgradeable) {
            updatePackageJSON(packageDef.trial, packageDef.licensed, pkgJSON);
        }
        fs.writeFile(packageJsonPath, cli_core_1.Util.formatPackageJson(pkgJSON));
        updateFileImports(logicFiles, styleFiles, upgradeable, fs);
        return true;
    });
}
exports.updateWorkspace = updateWorkspace;
function updateFileContent(fileContent, regexString, replaceWith) {
    const match = fileContent.match(new RegExp(regexString));
    if (match) {
        fileContent = fileContent.replace(new RegExp(regexString, "g"), `$1${replaceWith}$2${match.length === 4 ? "$3" : ""}`);
    }
    return fileContent;
}
function updateFileImports(logicFiles, styleFiles, packageDefs, fs) {
    for (const file of logicFiles) {
        let fileContent = fs.readFile(file);
        let fileChange = false;
        for (const packageDef of packageDefs) {
            if (fileContent.includes(packageDef.trial)) {
                const newContent = updateFileContent(fileContent, createExpression(RegularExpressionType.LOGIC, packageDef.trial), packageDef.licensed);
                fileChange = fileContent !== newContent;
                fileContent = newContent;
            }
        }
        if (fileChange) {
            fs.writeFile(file, fileContent);
        }
    }
    for (const file of styleFiles) {
        let fileContent = fs.readFile(file);
        let fileChange = false;
        for (const packageDef of packageDefs) {
            if (fileContent.includes(packageDef.trial)) {
                const newContent = updateFileContent(fileContent, createExpression(RegularExpressionType.STYLE, packageDef.trial), packageDef.licensed);
                fileChange = fileContent !== newContent;
                fileContent = newContent;
            }
        }
        if (fileChange) {
            fs.writeFile(file, fileContent);
        }
    }
}
function updatePackageJSON(initName, replaceWith, pkgJSON) {
    if (!pkgJSON.dependencies.hasOwnProperty(initName)) {
        return;
    }
    pkgJSON.dependencies[replaceWith] = pkgJSON.dependencies[initName];
    delete pkgJSON.dependencies[initName];
}
