"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const cli_core_1 = require("@igniteui/cli-core");
const package_resolve_1 = require("./package-resolve");
class MockFileSystem {
    fileExists(filePath) {
        throw new Error("Method not implemented.");
    }
    readFile(filePath, encoding) {
        throw new Error("Method not implemented.");
    }
    writeFile(filePath, text) {
        throw new Error("Method not implemented.");
    }
    directoryExists(dirPath) {
        throw new Error("Method not implemented.");
    }
    glob(dirPath, pattern) {
        throw new Error("Method not implemented.");
    }
}
describe("Igx templates - package resolve", () => {
    describe("resolveIgxPackage", () => {
        it("should return npm package as fallback", () => {
            const mockFs = new MockFileSystem();
            spyOn(mockFs, "fileExists").and.returnValue(false);
            cli_core_1.App.container.set(cli_core_1.FS_TOKEN, mockFs);
            const result = (0, package_resolve_1.resolveIgxPackage)(package_resolve_1.NPM_PACKAGE);
            expect(result).toEqual(package_resolve_1.NPM_PACKAGE);
            expect(mockFs.fileExists).toHaveBeenCalledWith("./package.json");
        });
        it("should return npm package if feed package in not in project", () => {
            const mockFs = new MockFileSystem();
            spyOn(mockFs, "fileExists").and.returnValue(true);
            const readSpy = spyOn(mockFs, "readFile").and.returnValue(`{ "dependencies": { "${package_resolve_1.NPM_PACKAGE}": "*" } }`);
            cli_core_1.App.container.set(cli_core_1.FS_TOKEN, mockFs);
            let result = (0, package_resolve_1.resolveIgxPackage)(package_resolve_1.NPM_PACKAGE);
            expect(result).toEqual(package_resolve_1.NPM_PACKAGE);
            expect(mockFs.fileExists).toHaveBeenCalledWith("./package.json");
            expect(mockFs.readFile).toHaveBeenCalledWith("./package.json");
            readSpy.and.returnValue(`{ "dependencies": { "${package_resolve_1.NPM_DOCK_MANAGER}": "*" } }`);
            result = (0, package_resolve_1.resolveIgxPackage)(package_resolve_1.NPM_DOCK_MANAGER);
            expect(result).toEqual(package_resolve_1.NPM_DOCK_MANAGER);
        });
        it("should return feed package if installed in project", () => {
            const mockFs = new MockFileSystem();
            spyOn(mockFs, "fileExists").and.returnValue(true);
            const readSpy = spyOn(mockFs, "readFile").and.returnValue(`{ "dependencies": { "${package_resolve_1.FEED_PACKAGE}": "*" } }`);
            cli_core_1.App.container.set(cli_core_1.FS_TOKEN, mockFs);
            let result = (0, package_resolve_1.resolveIgxPackage)(package_resolve_1.NPM_PACKAGE);
            expect(result).toEqual(package_resolve_1.FEED_PACKAGE);
            expect(mockFs.fileExists).toHaveBeenCalledWith("./package.json");
            expect(mockFs.readFile).toHaveBeenCalledWith("./package.json");
            readSpy.and.returnValue(`{ "dependencies": { "${package_resolve_1.FEED_DOCK_MANAGER}": "*" } }`);
            result = (0, package_resolve_1.resolveIgxPackage)(package_resolve_1.NPM_DOCK_MANAGER);
            expect(result).toEqual(package_resolve_1.FEED_DOCK_MANAGER);
        });
    });
    describe("getUpgradeablePackages", () => {
        it("should return an empty array if there are no upgradeable packages", () => {
            const mockFs = new MockFileSystem();
            const existsSpy = spyOn(mockFs, "fileExists").and.returnValue(false);
            cli_core_1.App.container.set(cli_core_1.FS_TOKEN, mockFs);
            expect((0, package_resolve_1.getUpgradeablePackages)()).toEqual([]);
            existsSpy.and.returnValue(true);
            spyOn(mockFs, "readFile").and.returnValue(JSON.stringify({
                dependencies: {
                    "@infragistics/igniteui-angular": "0.1.0",
                    "igniteui-bait": "^9.0.1",
                    "kek": "1.0.1"
                }
            }));
            expect((0, package_resolve_1.getUpgradeablePackages)()).toEqual([]);
        });
        it("should return an array if containing ONLY upgradeable packages", () => {
            const mockFs = new MockFileSystem();
            const existsSpy = spyOn(mockFs, "fileExists").and.returnValue(false);
            cli_core_1.App.container.set(cli_core_1.FS_TOKEN, mockFs);
            expect((0, package_resolve_1.getUpgradeablePackages)()).toEqual([]);
            existsSpy.and.returnValue(true);
            const mockObj = {
                dependencies: {
                    "@infragistics/igniteui-angular": "0.1.0",
                    "igniteui-angular": "^9.0.1",
                    "kek": "1.0.1"
                }
            };
            const mockRead = spyOn(mockFs, "readFile").and.returnValue(JSON.stringify(mockObj));
            const expected = [
                { trial: package_resolve_1.NPM_PACKAGE, licensed: package_resolve_1.FEED_PACKAGE }
            ];
            expect((0, package_resolve_1.getUpgradeablePackages)()).toEqual(expected);
            mockObj.dependencies = {
                "igniteui-angular": "^9.0.1",
                "igniteui-dockmanager": "0.1.0",
                "kek": "1.0.1"
            };
            expected.push({ trial: package_resolve_1.NPM_DOCK_MANAGER, licensed: package_resolve_1.FEED_DOCK_MANAGER });
            mockRead.and.returnValue(JSON.stringify(mockObj));
            expect((0, package_resolve_1.getUpgradeablePackages)()).toEqual(expected);
        });
    });
});
