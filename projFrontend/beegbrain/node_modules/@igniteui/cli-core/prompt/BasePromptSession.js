"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.BasePromptSession = void 0;
const inquirer = require("inquirer");
const path = require("path");
const util_1 = require("../util");
const TaskRunner_1 = require("./TaskRunner");
class BasePromptSession {
    constructor(templateManager) {
        this.templateManager = templateManager;
        /**
         * Task to pick action and load consecutive tasks
         * @param projectLibrary to add component to
         */
        this.chooseActionTask = (runner, context) => __awaiter(this, void 0, void 0, function* () {
            util_1.Util.log(""); /* new line */
            const action = yield this.getUserInput({
                type: "list",
                name: "action",
                message: "Choose an action:",
                choices: this.generateActionChoices(context.projectLibrary),
                default: "Complete & Run"
            });
            runner.clearPending();
            switch (action) {
                /* istanbul ignore next */
                case "Add all":
                    // internal testing only
                    runner.addTask((_runner, _context) => __awaiter(this, void 0, void 0, function* () {
                        const templateTask = this.templateSelectedTask();
                        for (const template of _context.projectLibrary.templates) {
                            _context.template = template;
                            yield templateTask(_runner, _context);
                        }
                        return true;
                    }));
                    runner.addTask(run => Promise.resolve(run.resetTasks()));
                    break;
                case "Add component":
                    runner.addTask(this.getComponentGroupTask);
                    runner.addTask(this.getComponentTask);
                    runner.addTask(this.getTemplateTask);
                    runner.addTask(this.templateSelectedTask());
                    runner.addTask(run => Promise.resolve(run.resetTasks()));
                    break;
                case "Add scenario":
                    runner.addTask(this.getCustomViewTask);
                    runner.addTask(this.templateSelectedTask("view"));
                    runner.addTask(run => Promise.resolve(run.resetTasks()));
                    break;
                case "Complete & Run":
                    const config = util_1.ProjectConfig.localConfig();
                    if (config.project.framework === "angular" &&
                        config.project.projectType === "igx-ts" &&
                        !config.packagesInstalled) {
                        // TODO: should we add check if there are paid components at all
                        util_1.Util.log("The project will be created using a Trial version of Ignite UI for Angular.");
                        util_1.Util.log("You can always run the upgrade-packages command once it's created.");
                        const shouldUpgrade = yield this.getUserInput({
                            type: "list",
                            name: "shouldUpgrade",
                            message: "Would you like to upgrade to the licensed feed now?",
                            choices: [
                                { value: "yes", name: "Yes (requires active subscription)", short: "Yes" },
                                { value: "no", name: "Skip for now", short: "Skip" }
                            ],
                            default: "yes"
                        });
                        if (shouldUpgrade === "yes") {
                            yield this.upgradePackages();
                        }
                    }
                    const defaultPort = config.project.defaultPort;
                    const port = yield this.getUserInput({
                        type: "input",
                        name: "port",
                        message: "Choose app host port:",
                        default: defaultPort,
                        validate: (input) => {
                            if (!Number(input)) {
                                util_1.Util.log(""); /* new line */
                                util_1.Util.error(`port should be a number. Input valid port or use the suggested default port`, "red");
                                return false;
                            }
                            return true;
                        }
                    });
                    config.project.defaultPort = parseInt(port, 10);
                    util_1.ProjectConfig.setConfig(config);
                    yield this.completeAndRun(config.project.defaultPort);
                    break;
            }
            return true;
        });
        /**
         * Get component group from user input
         * @param projectLibrary to add component to
         */
        this.getComponentGroupTask = (_runner, context) => __awaiter(this, void 0, void 0, function* () {
            const groups = context.projectLibrary.getComponentGroupNames();
            const groupRes = yield this.getUserInput({
                type: "list",
                name: "componentGroup",
                message: "Choose a group:",
                choices: util_1.Util.formatChoices(context.projectLibrary.getComponentGroups()),
                default: groups.find(x => x.includes("Grids")) || groups[0]
            }, true);
            if (groupRes === TaskRunner_1.WIZARD_BACK_OPTION) {
                return TaskRunner_1.WIZARD_BACK_OPTION;
            }
            context.group = groupRes;
            return true;
        });
        /**
         * Get component in the selected components group
         * @param projectLibrary to add component to
         * @param groupName to chose components from
         */
        this.getComponentTask = (_runner, context) => __awaiter(this, void 0, void 0, function* () {
            const componentNameRes = yield this.getUserInput({
                type: "list",
                name: "component",
                message: "Choose a component:",
                choices: util_1.Util.formatChoices(context.projectLibrary.getComponentsByGroup(context.group))
            }, true);
            if (componentNameRes === TaskRunner_1.WIZARD_BACK_OPTION) {
                return TaskRunner_1.WIZARD_BACK_OPTION;
            }
            context.component = context.projectLibrary.getComponentByName(componentNameRes);
            return true;
        });
        /**
         * Get template for selected component
         * @param projectLibrary to add component to
         * @param component to get template for
         */
        this.getTemplateTask = (_runner, context) => __awaiter(this, void 0, void 0, function* () {
            let selectedTemplate;
            const templates = context.component.templates;
            const templateRes = yield this.getUserInput({
                type: "list",
                name: "template",
                message: "Choose one:",
                choices: util_1.Util.formatChoices(templates)
            }, true);
            if (templateRes === TaskRunner_1.WIZARD_BACK_OPTION) {
                return TaskRunner_1.WIZARD_BACK_OPTION;
            }
            selectedTemplate = templates.find((value, i, obj) => {
                return value.name === templateRes;
            });
            if (selectedTemplate) {
                context.template = selectedTemplate;
                return true;
            }
            return false;
        });
        /**
         * Get template for custom view from user input
         * @param projectLibrary to add component to
         * @param theme to use to style the project
         */
        this.getCustomViewTask = (_runner, context) => __awaiter(this, void 0, void 0, function* () {
            const customTemplates = context.projectLibrary.getCustomTemplates();
            const customTemplateNameRes = yield this.getUserInput({
                type: "list",
                name: "customTemplate",
                message: "Choose custom view:",
                choices: util_1.Util.formatChoices(customTemplates)
            }, true);
            if (customTemplateNameRes === TaskRunner_1.WIZARD_BACK_OPTION) {
                return TaskRunner_1.WIZARD_BACK_OPTION;
            }
            const selectedTemplate = customTemplates.find((value, i, obj) => {
                return customTemplateNameRes === value.name;
            });
            if (selectedTemplate) {
                context.template = selectedTemplate;
                return true;
            }
            return false;
        });
    }
    /**
     * Start questions session for project creation
     */
    start() {
        return __awaiter(this, void 0, void 0, function* () {
            util_1.GoogleAnalytics.post({
                t: "screenview",
                cd: "Wizard"
            });
            let projLibrary;
            let theme;
            this.config = util_1.ProjectConfig.getConfig();
            const defaultProjName = "IG Project";
            if (util_1.ProjectConfig.hasLocalConfig() && !this.config.project.isShowcase) {
                projLibrary = this.templateManager.getProjectLibrary(this.config.project.framework, this.config.project.projectType);
                theme = this.config.project.theme;
            }
            else {
                util_1.Util.log(""); /* new line */
                const projectName = yield this.getUserInput({
                    type: "input",
                    name: "projectName",
                    message: "Enter a name for your project:",
                    default: util_1.Util.getAvailableName(defaultProjName, true),
                    validate: this.nameIsValid
                });
                const frameRes = yield this.getUserInput({
                    type: "list",
                    name: "framework",
                    message: "Choose framework:",
                    choices: this.getFrameworkNames(),
                    default: "jQuery"
                });
                const framework = this.templateManager.getFrameworkByName(frameRes);
                // app name validation???
                projLibrary = yield this.getProjectLibrary(framework);
                const projTemplate = yield this.getProjectTemplate(projLibrary);
                // project options:
                theme = yield this.getTheme(projLibrary);
                util_1.Util.log("  Generating project structure.");
                const config = projTemplate.generateConfig(projectName, theme);
                for (const templatePath of projTemplate.templatePaths) {
                    yield util_1.Util.processTemplates(templatePath, path.join(process.cwd(), projectName), config, projTemplate.delimiters, false);
                }
                util_1.Util.log(util_1.Util.greenCheck() + " Project structure generated.");
                if (!this.config.skipGit) {
                    util_1.Util.gitInit(process.cwd(), projectName);
                }
                // move cwd to project folder
                process.chdir(projectName);
            }
            yield this.chooseActionLoop(projLibrary);
            //TODO: restore cwd?
        });
    }
    /**
     * Starts a loop of 'Choose an action' questions
     * @param projectLibrary The framework to use
     * @param theme Theme to use
     */
    chooseActionLoop(projectLibrary) {
        return __awaiter(this, void 0, void 0, function* () {
            const taskContext = { projectLibrary };
            const runner = new TaskRunner_1.TaskRunner(taskContext);
            runner.addTask(this.chooseActionTask);
            while (!runner.done) {
                yield runner.run();
            }
        });
    }
    /**
     * Gets the user input according to provided `options`.Returns directly if single choice is provided.
     * @param options to use for the user input
     * @param withBackChoice Add a "Back" option to choices list
     */
    getUserInput(options, withBackChoice = false) {
        return __awaiter(this, void 0, void 0, function* () {
            if (options.choices) {
                if (options.choices.length < 2) {
                    // single choice to return:
                    let choice = options.choices[0];
                    choice = choice.value || choice;
                    this.logAutoSelected(options, choice);
                    return choice;
                }
                if (withBackChoice) {
                    options.choices.push(TaskRunner_1.WIZARD_BACK_OPTION);
                }
                options.choices = this.addSeparators(options.choices);
            }
            const userInput = yield inquirer.prompt(options);
            const result = userInput[options.name];
            // post to GA everything but 'Back' user choice
            if (!withBackChoice || result !== TaskRunner_1.WIZARD_BACK_OPTION) {
                util_1.GoogleAnalytics.post({
                    t: "event",
                    ec: "$ig wizard",
                    el: options.message,
                    ea: `${options.name}: ${result}`
                });
            }
            else {
                util_1.GoogleAnalytics.post({
                    t: "event",
                    ec: "$ig wizard",
                    el: result,
                    ea: `Back from ${options.name}`
                });
            }
            return result;
        });
    }
    /**
     * Check if provided @param name is valid for project name
     * @param name the name to check
     * @param checkFolder check if folder with this name already exists
     */
    nameIsValid(name, checkFolder = true) {
        if (!util_1.Util.isAlphanumericExt(name)) {
            util_1.Util.log(""); /* new line */
            util_1.Util.error(`Name '${name}' is not valid. `
                + "Name should start with a letter and can also contain numbers, dashes and spaces.", "red");
            return false;
        }
        if (checkFolder && util_1.Util.directoryExists(name)) {
            util_1.Util.log(""); /* new line */
            util_1.Util.error(`Folder "${name}" already exists!`, "red");
            return false;
        }
        return true;
    }
    /** Returns the framework names, potentially filtered by config */
    getFrameworkNames() {
        let frameworksNames = [];
        if (this.config.stepByStep &&
            this.config.stepByStep.frameworks &&
            this.config.stepByStep.frameworks.length) {
            this.config.stepByStep.frameworks.forEach(x => {
                const framework = this.templateManager.getFrameworkById(x);
                if (framework) {
                    frameworksNames.push(framework.name);
                }
            });
        }
        if (!frameworksNames.length) {
            // no config or wrong projTypes array:
            frameworksNames = this.templateManager.getFrameworkNames();
        }
        return frameworksNames;
    }
    /**
     * Gets the project library from the user input, or default if provided @param framework has single project library
     * @param framework to get project library for
     */
    getProjectLibrary(framework) {
        return __awaiter(this, void 0, void 0, function* () {
            let projectLibrary;
            const projectLibraries = this.getProjectLibNames(framework);
            const projectRes = yield this.getUserInput({
                type: "list",
                name: "projectType",
                message: "Choose the type of project:",
                choices: projectLibraries
            });
            projectLibrary = this.templateManager.getProjectLibraryByName(framework, projectRes);
            return projectLibrary;
        });
    }
    /**
     * Gets project template from user input, or default if provided `projectLibrary` has a single template
     * @param projectLibrary to get theme for
     */
    getProjectTemplate(projectLibrary) {
        return __awaiter(this, void 0, void 0, function* () {
            let projTemplate;
            const componentNameRes = yield this.getUserInput({
                type: "list",
                name: "projTemplate",
                message: "Choose project template:",
                choices: util_1.Util.formatChoices(projectLibrary.projects)
            });
            projTemplate = projectLibrary.projects.find(x => x.name === componentNameRes);
            return projTemplate;
        });
    }
    /**
     * Gets the theme from the user input, or default if provided @param projectLibrary has a single theme
     * @param projectLibrary to get theme for
     */
    getTheme(projectLibrary) {
        return __awaiter(this, void 0, void 0, function* () {
            let theme;
            theme = yield this.getUserInput({
                type: "list",
                name: "theme",
                message: "Choose the theme for the project:",
                choices: projectLibrary.themes,
                default: projectLibrary.themes[0]
            });
            return theme;
        });
    }
    /**
     * Prompt user for template name with appropriate default
     * @param template template to get name for
     * @param type type of the name question
     */
    chooseTemplateName(template, type = "component") {
        return __awaiter(this, void 0, void 0, function* () {
            const config = util_1.ProjectConfig.getConfig();
            const availableDefaultName = util_1.Util.getAvailableName(template.name, false, config.project.framework, config.project.projectType);
            const templateName = yield this.getUserInput({
                type: "input",
                name: `${type === "component" ? type : "customView"}Name`,
                message: `Name your ${type}:`,
                default: availableDefaultName,
                validate: (input) => {
                    // TODO: GA post?
                    const name = util_1.Util.nameFromPath(input);
                    return this.nameIsValid(name, false);
                }
            });
            return templateName;
        });
    }
    /** Create prompts from template extra configuration and assign user answers to the template */
    customizeTemplateTask(template) {
        return __awaiter(this, void 0, void 0, function* () {
            const extraPrompt = this.createQuestions(template.getExtraConfiguration());
            const extraConfigAnswers = yield inquirer.prompt(extraPrompt);
            const extraConfig = this.parseAnswers(extraConfigAnswers);
            util_1.GoogleAnalytics.post({
                t: "event",
                ec: "$ig wizard",
                el: "Extra configuration:",
                ea: `extra configuration: ${JSON.stringify(extraConfig)}`
            });
            template.setExtraConfiguration(extraConfig);
        });
    }
    /**
     * Returns a new array with inquirer.Separator() added between items
     * @param array The original array to add separator to
     */
    addSeparators(array) {
        const newArray = [];
        for (let i = 0; i < array.length; i++) {
            newArray.push(array[i]);
            if (i + 1 < array.length) {
                newArray.push(new inquirer.Separator());
            }
        }
        if (array.length > 4) {
            // additional separator after last item for lists that wrap around
            newArray.push(new inquirer.Separator(new Array(15).join("=")));
        }
        return newArray;
    }
    /**
     * Generate questions from extra configuration array
     * @param extraConfig
     */
    createQuestions(extraConfig) {
        const result = [];
        for (const element of extraConfig) {
            const currExtraConfig = {};
            switch (element.type) {
                case 0 /* Choice */:
                    currExtraConfig["type"] = "list";
                    break;
                case 1 /* MultiChoice */:
                    currExtraConfig["type"] = "checkbox";
                    break;
                case 2 /* Value */:
                default:
                    currExtraConfig["type"] = "input";
                    break;
            }
            currExtraConfig["default"] = element.default;
            currExtraConfig["message"] = element.message;
            currExtraConfig["name"] = element.key;
            currExtraConfig["choices"] = element.choices;
            result.push(currExtraConfig);
        }
        return result;
    }
    /**
     * Conversion placeholder
     * @param answers
     */
    parseAnswers(answers) {
        return answers;
    }
    logAutoSelected(options, choice) {
        let text;
        switch (options.name) {
            case "framework":
                text = `  Framework`;
                break;
            case "projectType":
                text = `  Project type`;
                break;
            case "projTemplate":
                text = `  Proj Template`;
                break;
            case "theme":
                text = `  Theme`;
                break;
            default:
                return;
            //TODO: text = `  ${options.name}`;
        }
        util_1.GoogleAnalytics.post({
            t: "event",
            ec: "$ig wizard",
            el: options.message,
            ea: `${options.name}: ${choice}`
        });
        util_1.Util.log(`${text}: ${choice}`);
    }
    /** Returns the projectLibraries names, potentially filtered by config */
    getProjectLibNames(framework) {
        let projectLibraries = [];
        const frameworkConfig = this.config.stepByStep && this.config.stepByStep[framework.id];
        if (frameworkConfig && frameworkConfig.projTypes && frameworkConfig.projTypes.length) {
            frameworkConfig.projTypes.forEach(x => {
                const projLib = framework.projectLibraries.find(p => p.projectType === x);
                if (projLib) {
                    projectLibraries.push(projLib.name);
                }
            });
        }
        if (!projectLibraries.length) {
            // no config or wrong projTypes array:
            projectLibraries = this.templateManager.getProjectLibraryNames(framework.id);
        }
        return projectLibraries;
    }
    /**
     * Generates a list of options for chooseActionLoop
     * @param projectLibrary to generate options for
     */
    generateActionChoices(projectLibrary) {
        const actionChoices = [
            { name: "Complete & Run", description: "install packages and run in the default browser" }
        ];
        /* istanbul ignore next */
        if (util_1.App.testMode) {
            // internal testing only
            actionChoices.push({ name: "Add all", description: "add all components/views" });
        }
        if (projectLibrary.components.length > 0) {
            actionChoices.push({ name: "Add component", description: "add a specific component view (e.g a grid)" });
        }
        if (projectLibrary.getCustomTemplateNames().length > 0) {
            actionChoices.push({ name: "Add scenario", description: "add a predefined scenario view (e.g grid or dashboard)" });
        }
        return util_1.Util.formatChoices(actionChoices, 10);
    }
}
exports.BasePromptSession = BasePromptSession;
