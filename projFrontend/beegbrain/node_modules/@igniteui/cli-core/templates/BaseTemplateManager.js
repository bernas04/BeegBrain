"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.BaseTemplateManager = void 0;
const path = require("path");
const util_1 = require("../util");
class BaseTemplateManager {
    constructor(templatesAbsPath) {
        this.templatesAbsPath = templatesAbsPath;
        this._quickstartTemplatesPath = "quickstart";
        this.frameworks = [];
        // read dirs and push dir names into frameworks
        const frameworks = util_1.Util.getDirectoryNames(this.templatesAbsPath)
            .filter(x => x !== this._quickstartTemplatesPath);
        // load and initialize templates
        for (const framework of frameworks) {
            this.frameworks.push(require(path.join(this.templatesAbsPath, framework)));
        }
        // load external templates
        this.loadExternalTemplates();
    }
    getFrameworkIds() {
        return this.frameworks.map(f => f.id);
    }
    getFrameworkNames() {
        // Ðµxclude WebComponents from the Step-By-Step wizard
        return this.frameworks.map(f => f.name);
    }
    /**  Returns framework found by its name or undefined. */
    getFrameworkByName(name) {
        return this.frameworks.find(s => s.name === name);
    }
    /**  Returns framework found by its ID or undefined. */
    getFrameworkById(id) {
        return this.frameworks.find(f => f.id === id);
    }
    /**
     * Get ProjectLibrary Names list
     * @param frameworkId
     * @returns Returns projectLibrary names array
     */
    getProjectLibraryNames(frameworkId) {
        let projects = [];
        const framework = this.frameworks.find(f => f.id === frameworkId);
        if (framework) {
            projects = framework.projectLibraries.map(x => x.name);
        }
        return projects;
    }
    /**
     * Get ProjectLibrary by name
     * @param framework
     * @param name
     * @returns Returns matching projectLibrary or undefined
     */
    getProjectLibraryByName(framework, name) {
        let projectLib;
        if (name) {
            projectLib = framework.projectLibraries.find(x => x.name === name);
        }
        return projectLib;
    }
    /**
     * Get a specific project library
     * @param frameworkId
     * @param projectType
     * @returns Returns projectLibrary, or null.
     */
    getProjectLibrary(frameworkId, projectType) {
        const framework = this.frameworks.find(f => f.id === frameworkId);
        if (framework) {
            if (projectType) {
                return framework.projectLibraries.find(x => x.projectType === projectType);
            }
            else {
                return framework.projectLibraries.length > 0 ? framework.projectLibraries[0] : null;
            }
        }
        return null;
    }
    updateProjectConfiguration(template) {
        const config = util_1.ProjectConfig.getConfig();
        // add each separately to avoid duplicates:
        for (const element of template.dependencies) {
            if (typeof element === "string" && config.project.components.indexOf(element) === -1) {
                config.project.components.push(element);
            }
        }
        util_1.ProjectConfig.setConfig(config);
    }
    /** Read config and load custom templates based on type */
    loadExternalTemplates() {
        const config = util_1.ProjectConfig.getConfig();
        const customTemplates = [];
        for (const entry of config.customTemplates) {
            let template;
            // tslint:disable-next-line:prefer-const
            let [protocol, value] = entry.split(/(^[^:]+):/).filter(x => x);
            switch (protocol) {
                default:
                    // in case just path is passed:
                    value = entry;
                case "file":
                case "path":
                    value = value.replace(/template\.json$/, "");
                    if (util_1.Util.directoryExists(value)) {
                        // try single template
                        template = this.loadFromConfig(path.join(value, "template.json"));
                        if (template !== null) {
                            customTemplates.push(template);
                            break;
                        }
                        // try folder of templates:
                        for (const folder of util_1.Util.getDirectoryNames(value)) {
                            template = this.loadFromConfig(path.join(value, folder, "template.json"));
                            if (template !== null) {
                                customTemplates.push(template);
                            }
                        }
                    }
                    else {
                        // TODO: Util.log(`Ignored: Incorrect custom template path for "${entry}".`);
                    }
                    break;
                case "ignored":
                    break;
            }
        }
        this.addTemplates(customTemplates);
    }
    addTemplates(templates) {
        for (const template of templates) {
            const projectLib = this.getProjectLibrary(template.framework, template.projectType);
            if (!projectLib) {
                util_1.Util.error(`The framework/project type for template with id "${template.id}" is not supported.`);
                continue;
            }
            if (projectLib.hasTemplate(template.id)) {
                util_1.Util.error(`Template with id "${template.id}" already exists.`);
                continue;
            }
            if (projectLib.getComponentGroupNames().indexOf(template.controlGroup) === -1 && !template.listInCustomTemplates) {
                util_1.Util.error(`No supported group for template with id "${template.id}".`);
                continue;
            }
            projectLib.registerTemplate(template);
        }
    }
}
exports.BaseTemplateManager = BaseTemplateManager;
