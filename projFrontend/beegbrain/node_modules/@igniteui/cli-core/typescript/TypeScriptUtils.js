"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.TypeScriptUtils = void 0;
// tslint:disable-next-line:no-implicit-dependencies
const ts = require("typescript");
const FileSystem_1 = require("../types/FileSystem");
const util_1 = require("../util");
const Util_1 = require("../util/Util");
class TypeScriptUtils {
    //#region Node manipulation utils
    /**
     * Create a node for named import (like `import { ${className} } from "${filePath}"`)
     * @param identifierName Name of the identifier (class, variable)
     * @param importPath Path to import from
     */
    static createIdentifierImport(identifierNames, importPath) {
        // started from createImportDeclaration, now we here...
        const namedImport = ts.factory.createNamedImports(identifierNames.map(x => ts.factory.createImportSpecifier(false, undefined, ts.factory.createIdentifier(x))));
        const importClause = ts.factory.createImportClause(false, undefined, namedImport);
        const importDeclaration = ts.factory.createImportDeclaration(undefined, undefined, importClause, ts.factory.createStringLiteral(importPath));
        return importDeclaration;
    }
    /**
     * Creates a `ts.Expression` for an identifier with optional method call
     * @param x Identifier text
     * @param call Method to call, creating `x.call()`
     */
    static createIdentifier(x, call) {
        if (call) {
            return ts.factory.createCallExpression(ts.factory.createPropertyAccessExpression(ts.factory.createIdentifier(x), call), 
            /*typeArgs*/ undefined, 
            /*argsArgs*/ []);
        }
        else {
            return ts.factory.createIdentifier(x);
        }
    }
    /**
     * Checks based on https://github.com/Microsoft/TypeScript/wiki/Using-the-Compiler-API#using-the-type-checker
     * @param nodes Source nodes to iterate
     */
    static getClassName(nodes) {
        for (const node of nodes) {
            if (node.kind === ts.SyntaxKind.ClassDeclaration && this.isNodeExported(node)) {
                const identifier = node.name;
                return identifier.text;
            }
            else if (node.kind === ts.SyntaxKind.ModuleDeclaration ||
                node.kind === ts.SyntaxKind.SyntaxList) {
                // selective children check; checking getChildCount() throws
                const res = this.getClassName(node.getChildren());
                if (res !== null) {
                    // stop and return
                    return res;
                }
            }
        }
        return null;
    }
    /** True if this is visible outside this file, false otherwise */
    static isNodeExported(node) {
        return (node.flags & ts.NodeFlags.ExportContext) !== 0 ||
            (node.parent && node.parent.kind === ts.SyntaxKind.SourceFile);
    }
    /**
     * Returns node identifier name. Either direct `ts.Identifier` equivalent or simple `ts.CallExpression` supported.
     * Calls with single property access will return the first identifier name (eg. `returnText.propCall()`)
     * @param x Node to extract identifier text from.
     */
    static getIdentifierName(x) {
        if (x.kind === ts.SyntaxKind.CallExpression) {
            const prop = x.expression;
            //pluck identifier from expression.name
            x = prop.expression;
        }
        return x.text;
    }
    //#endregion Node manipulation utils
    //#region Utility functions
    /**
     * Returns an source file, adds new line placeholders as the TS parser won't add `SyntaxKind.NewLineTrivia` to the AST.
     * @param filePath Path of file to read
     */
    static getFileSource(filePath) {
        const fileSystem = util_1.App.container.get(FileSystem_1.FS_TOKEN);
        let targetFile = fileSystem.readFile(filePath);
        targetFile = targetFile.replace(/(\r?\n)(\r?\n)/g, `$1${this.newLinePlaceHolder}$2`);
        const targetSource = ts.createSourceFile(filePath, targetFile, ts.ScriptTarget.Latest, true);
        return targetSource;
    }
    /**
     * Prints source, removes new line placeholders and saves the output in a target file
     * @param filePath File path
     * @param source Source AST to print
     */
    static saveFile(filePath, source) {
        const fileSystem = util_1.App.container.get(FileSystem_1.FS_TOKEN);
        // https://github.com/Microsoft/TypeScript/issues/10786#issuecomment-288987738
        const printer = ts.createPrinter();
        let text = printer.printFile(source);
        text = text.replace(new RegExp(`(\r?\n)\\s*?${Util_1.Util.escapeRegExp(this.newLinePlaceHolder)}(\r?\n)`, "g"), `$1$2`);
        fileSystem.writeFile(filePath, text);
    }
}
exports.TypeScriptUtils = TypeScriptUtils;
TypeScriptUtils.newLinePlaceHolder = "//I keep the new line";
