"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.TypeScriptFileUpdate = void 0;
const ts = require("typescript");
const __1 = require("..");
const FileSystem_1 = require("../types/FileSystem");
const Util_1 = require("../util/Util");
const TypeScriptUtils_1 = require("./TypeScriptUtils");
const DEFAULT_ROUTES_VARIABLE = "routes";
/**
 * Apply various updates to typescript files using AST
 */
class TypeScriptFileUpdate {
    /** Create updates for a file. Use `add<X>` methods to add transformations and `finalize` to apply and save them. */
    constructor(targetPath) {
        this.targetPath = targetPath;
        // https://github.com/Microsoft/TypeScript/wiki/Using-the-Compiler-API for general source parsing
        // http://blog.scottlogic.com/2017/05/02/typescript-compiler-api-revisited.html
        // for AST transformation API List: https://github.com/Microsoft/TypeScript/pull/13940
        this.formatOptions = { spaces: false, indentSize: 4, singleQuotes: false };
        //#region ts.TransformerFactory
        /** Transformation to apply edits to existing named import declarations */
        this.importsTransformer = (context) => (rootNode) => {
            const editImports = this.requestedImports.filter(x => x.edit);
            // https://github.com/Microsoft/TypeScript/issues/14419#issuecomment-307256171
            const visitor = (node) => {
                if (node.kind === ts.SyntaxKind.ImportDeclaration &&
                    editImports.find(x => x.from === node.moduleSpecifier.text)) {
                    // visit just the source file main array (second visit)
                    return visitImport(node);
                }
                else {
                    node = ts.visitEachChild(node, visitor, context);
                }
                return node;
            };
            function visitImport(node) {
                if (node.kind === ts.SyntaxKind.NamedImports) {
                    const namedImports = node;
                    const moduleSpecifier = namedImports.parent.parent.moduleSpecifier.text;
                    const existing = ts.visitNodes(namedImports.elements, visitor);
                    const alreadyImported = existing.map(x => x.name.text);
                    const editImport = editImports.find(x => x.from === moduleSpecifier);
                    const newImports = editImport.imports.filter(x => alreadyImported.indexOf(x) === -1);
                    node = ts.factory.updateNamedImports(namedImports, [
                        ...existing,
                        ...newImports.map(x => ts.factory.createImportSpecifier(false, undefined, ts.factory.createIdentifier(x)))
                    ]);
                }
                else {
                    node = ts.visitEachChild(node, visitImport, context);
                }
                return node;
            }
            return ts.visitNode(rootNode, visitor);
        };
        /** Transformation to apply `this.ngMetaEdits` to `NgModule` metadata properties */
        this.ngModuleTransformer = (context) => (rootNode) => {
            const visitNgModule = (node) => {
                const properties = []; // "declarations", "imports", "providers"
                for (const key in this.ngMetaEdits) {
                    if (this.ngMetaEdits[key].length) {
                        properties.push(key);
                    }
                }
                if (node.kind === ts.SyntaxKind.ObjectLiteralExpression &&
                    node.parent &&
                    node.parent.kind === ts.SyntaxKind.CallExpression) {
                    let obj = node;
                    //TODO: test node.parent for ts.CallExpression NgModule
                    const missingProperties = properties.filter(x => !obj.properties.find(o => o.name.getText() === x));
                    // skip visiting if no declaration/imports/providers arrays exist:
                    if (missingProperties.length !== properties.length) {
                        obj = ts.visitEachChild(node, visitNgModule, context);
                    }
                    if (!missingProperties.length) {
                        return obj;
                    }
                    const objProperties = ts.visitNodes(obj.properties, visitor);
                    const newProps = [];
                    for (const prop of missingProperties) {
                        let arrayExpr;
                        switch (prop) {
                            case "imports":
                                const importDeps = this.ngMetaEdits.imports;
                                arrayExpr = ts.factory.createArrayLiteralExpression(importDeps.map(x => TypeScriptUtils_1.TypeScriptUtils.createIdentifier(x.name, x.root ? "forRoot" : "")));
                                break;
                            case "declarations":
                            case "providers":
                            case "exports":
                                arrayExpr = ts.factory.createArrayLiteralExpression(this.ngMetaEdits[prop].map(x => ts.factory.createIdentifier(x)));
                                break;
                        }
                        newProps.push(ts.factory.createPropertyAssignment(prop, arrayExpr));
                    }
                    return ts.updateObjectLiteral(obj, [
                        ...objProperties,
                        ...newProps
                    ]);
                }
                else if (node.kind === ts.SyntaxKind.ArrayLiteralExpression &&
                    node.parent.kind === ts.SyntaxKind.PropertyAssignment &&
                    properties.indexOf(node.parent.name.getText()) !== -1) {
                    const initializer = node;
                    const props = ts.visitNodes(initializer.elements, visitor);
                    const alreadyImported = props.map(x => TypeScriptUtils_1.TypeScriptUtils.getIdentifierName(x));
                    const prop = properties.find(x => x === node.parent.name.getText());
                    let identifiers = [];
                    switch (prop) {
                        case "imports":
                            identifiers = this.ngMetaEdits.imports
                                .filter(x => alreadyImported.indexOf(x.name) === -1)
                                .map(x => TypeScriptUtils_1.TypeScriptUtils.createIdentifier(x.name, x.root ? "forRoot" : ""));
                            break;
                        case "declarations":
                        case "providers":
                        case "exports":
                            identifiers = this.ngMetaEdits[prop]
                                .filter(x => alreadyImported.indexOf(x) === -1)
                                .map(x => ts.factory.createIdentifier(x));
                            break;
                    }
                    const elements = ts.factory.createNodeArray([
                        ...props,
                        ...identifiers
                    ]);
                    return ts.factory.updateArrayLiteralExpression(initializer, elements);
                }
                else {
                    node = ts.visitEachChild(node, visitNgModule, context);
                }
                return node;
            };
            const visitCondition = (node) => {
                return node.kind === ts.SyntaxKind.CallExpression &&
                    node.parent && node.parent.kind === ts.SyntaxKind.Decorator &&
                    node.expression.getText() === "NgModule";
            };
            const visitor = this.createVisitor(visitNgModule, visitCondition, context);
            return ts.visitNode(rootNode, visitor);
        };
        this.fileSystem = __1.App.container.get(FileSystem_1.FS_TOKEN);
        this.initState();
    }
    /** Applies accumulated transforms, saves and formats the file */
    finalize() {
        const transforms = [];
        // walk AST for modifications.
        if (this.requestedImports.filter(x => x.edit).length) {
            transforms.push(this.importsTransformer);
        }
        if (Object.keys(this.ngMetaEdits).filter(x => this.ngMetaEdits[x].length).length) {
            transforms.push(this.ngModuleTransformer);
        }
        if (transforms.length) {
            this.targetSource = ts.transform(this.targetSource, transforms).transformed[0];
        }
        // add new import statements after visitor walks:
        this.addNewFileImports();
        TypeScriptUtils_1.TypeScriptUtils.saveFile(this.targetPath, this.targetSource);
        this.formatFile(this.targetPath);
        // reset state in case of further updates
        this.initState();
    }
    /**
     * Create configuration object for a component and add it to the `Routes` array variable.
     * Imports the first exported class and finalizes the file update (see `.finalize()`).
     * @param filePath Path to the component file to import
     * @param linkPath Routing `path` to add
     * @param linkText Text of the route to add as `data.text`
     * @param parentRoutePath Will include the new route as a **child** of the specified route path
     * @param routesVariable Name of the array variable holding routes
     */
    addChildRoute(filePath, linkPath, linkText, parentRoutePath, routesVariable = DEFAULT_ROUTES_VARIABLE) {
        this.addRouteModuleEntry(filePath, linkPath, linkText, routesVariable, parentRoutePath);
    }
    /**
     * Create configuration object for a component and add it to the `Routes` array variable.
     * Imports the first exported class and finalizes the file update (see `.finalize()`).
     * @param filePath Path to the component file to import
     * @param linkPath Routing `path` to add
     * @param linkText Text of the route to add as `data.text`
     * @param routesVariable Name of the array variable holding routes
     */
    addRoute(filePath, linkPath, linkText, routesVariable = DEFAULT_ROUTES_VARIABLE) {
        this.addRouteModuleEntry(filePath, linkPath, linkText, routesVariable);
    }
    /**
     * Import class and add it to `NgModule` declarations.
     * Creates `declarations` array if one is not present already.
     * @param filePath Path to the file to import
     */
    addDeclaration(filePath, addToExport) {
        let className;
        const fileSource = TypeScriptUtils_1.TypeScriptUtils.getFileSource(filePath);
        const relativePath = Util_1.Util.relativePath(this.targetPath, filePath, true, true);
        className = TypeScriptUtils_1.TypeScriptUtils.getClassName(fileSource.getChildren());
        if (addToExport) {
            this.addNgModuleMeta({ declare: className, from: relativePath, export: className });
        }
        else {
            this.addNgModuleMeta({ declare: className, from: relativePath });
        }
    }
    /**
     * Add a metadata update to the file's `NgModule`. Will also import identifiers.
     */
    addNgModuleMeta(dep, variables) {
        const copy = {
            declare: this.asArray(dep.declare, variables),
            import: this.asArray(dep.import, variables),
            provide: this.asArray(dep.provide, variables),
            // tslint:disable-next-line:object-literal-sort-keys
            export: this.asArray(dep.export, variables)
        };
        if (dep.from) {
            // request import
            const identifiers = [...copy.import, ...copy.declare, ...copy.provide];
            this.requestImport(identifiers, Util_1.Util.applyConfigTransformation(dep.from, variables));
        }
        const imports = copy.import
            .map(x => ({ name: x, root: dep.root }))
            .filter(x => !this.ngMetaEdits.imports.find(i => i.name === x.name));
        this.ngMetaEdits.imports.push(...imports);
        const declarations = copy.declare
            .filter(x => !this.ngMetaEdits.declarations.find(d => d === x));
        this.ngMetaEdits.declarations.push(...declarations);
        const providers = copy.provide
            .filter(x => !this.ngMetaEdits.providers.find(p => p === x));
        this.ngMetaEdits.providers.push(...providers);
        const exportsArr = copy.export
            .filter(x => !this.ngMetaEdits.exports.find(p => p === x));
        this.ngMetaEdits.exports.push(...exportsArr);
    }
    //#region File state
    /** Initializes existing imports info, [re]sets import and `NgModule` edits */
    initState() {
        this.targetSource = TypeScriptUtils_1.TypeScriptUtils.getFileSource(this.targetPath);
        this.importsMeta = this.loadImportsMeta();
        this.requestedImports = [];
        this.ngMetaEdits = {
            declarations: [],
            imports: [],
            providers: [],
            exports: []
        };
        this.createdStringLiterals = [];
    }
    /* load some metadata about imports */
    loadImportsMeta() {
        const meta = { lastIndex: 0, modulePaths: [] };
        for (let i = 0; i < this.targetSource.statements.length; i++) {
            const statement = this.targetSource.statements[i];
            switch (statement.kind) {
                case ts.SyntaxKind.ImportDeclaration:
                    const importStmt = statement;
                    if (importStmt.importClause && importStmt.importClause.namedBindings &&
                        importStmt.importClause.namedBindings.kind !== ts.SyntaxKind.NamespaceImport) {
                        // don't add imports without named (e.g. `import $ from "JQuery"` or `import "./my-module.js";`)
                        // don't add namespace imports (`import * as fs`) as available for editing, maybe in the future
                        meta.modulePaths.push(importStmt.moduleSpecifier.text);
                    }
                // don't add equals imports (`import url = require("url")`) as available for editing, maybe in the future
                case ts.SyntaxKind.ImportEqualsDeclaration:
                    meta.lastIndex = i + 1;
                    break;
                default:
                    break;
            }
        }
        return meta;
    }
    //#endregion File state
    addRouteModuleEntry(filePath, linkPath, linkText, routesVariable = DEFAULT_ROUTES_VARIABLE, parentRoutePath) {
        let className;
        const fileSource = TypeScriptUtils_1.TypeScriptUtils.getFileSource(filePath);
        const relativePath = Util_1.Util.relativePath(this.targetPath, filePath, true, true);
        className = TypeScriptUtils_1.TypeScriptUtils.getClassName(fileSource.getChildren());
        this.requestImport([className], relativePath);
        // https://github.com/Microsoft/TypeScript/issues/14419#issuecomment-307256171
        const transformer = (context) => (rootNode) => {
            let conditionalVisitor;
            // the visitor that should be used when adding routes to the main route array
            const routeArrayVisitor = (node) => {
                if (node.kind === ts.SyntaxKind.ArrayLiteralExpression) {
                    const newObject = this.createRouteEntry(linkPath, className, linkText);
                    const array = node;
                    this.createdStringLiterals.push(linkPath, linkText);
                    const notFoundWildCard = "**";
                    const nodes = ts.visitNodes(array.elements, visitor);
                    const errorRouteNode = nodes.filter(element => element.getText().includes(notFoundWildCard))[0];
                    let resultNodes = null;
                    if (errorRouteNode) {
                        resultNodes = nodes
                            .slice(0, nodes.indexOf(errorRouteNode))
                            .concat(newObject)
                            .concat(errorRouteNode);
                    }
                    else {
                        resultNodes = nodes
                            .concat(newObject);
                    }
                    const elements = ts.factory.createNodeArray([
                        ...resultNodes
                    ]);
                    return ts.factory.updateArrayLiteralExpression(array, elements);
                }
                else {
                    return ts.visitEachChild(node, conditionalVisitor, context);
                }
            };
            // the visitor that should be used when adding child routes to a specified parent
            const parentRouteVisitor = (node) => {
                if (node.kind === ts.SyntaxKind.ObjectLiteralExpression) {
                    if (!node.getText().includes(parentRoutePath)) {
                        return node;
                    }
                    const nodeProperties = node.properties;
                    const parentPropertyCheck = (element) => {
                        return element.name.kind === ts.SyntaxKind.Identifier && element.name.text === "path"
                            && element.initializer.kind === ts.SyntaxKind.StringLiteral
                            && element.initializer.text === parentRoutePath;
                    };
                    const parentProperty = nodeProperties.filter(parentPropertyCheck)[0];
                    if (!parentProperty) {
                        return node;
                    }
                    function filterForChildren(element) {
                        if (element.kind === ts.SyntaxKind.PropertyAssignment) {
                            const identifier = element.getChildren()[0];
                            return identifier.kind === ts.SyntaxKind.Identifier && identifier.getText().trim() === "children";
                        }
                        return false;
                    }
                    const newObject = this.createRouteEntry(linkPath, className, linkText);
                    const currentNode = node;
                    this.createdStringLiterals.push(linkPath, linkText);
                    const syntaxList = node.getChildren()
                        .filter(element => element.kind === ts.SyntaxKind.SyntaxList)[0];
                    let childrenProperty = syntaxList
                        .getChildren().filter(filterForChildren)[0];
                    let childrenArray = null;
                    // if the target parent route already has child routes - get them
                    // if not - create an empty 'chuldren' array
                    if (childrenProperty) {
                        childrenArray = childrenProperty.getChildren()
                            .filter(element => element.kind === ts.SyntaxKind.ArrayLiteralExpression)[0]
                            || ts.factory.createArrayLiteralExpression();
                    }
                    else {
                        childrenArray = ts.factory.createArrayLiteralExpression();
                    }
                    let existingProperties = syntaxList.getChildren()
                        .filter(element => element.kind !== ts.SyntaxKind["CommaToken"]);
                    const newArrayValues = childrenArray.elements.concat(newObject);
                    if (!childrenProperty) {
                        const propertyName = "children";
                        const propertyValue = ts.factory.createArrayLiteralExpression([...newArrayValues]);
                        childrenProperty = ts.factory.createPropertyAssignment(propertyName, propertyValue);
                        existingProperties = existingProperties
                            .concat(childrenProperty);
                    }
                    else {
                        const index = existingProperties.indexOf(childrenProperty);
                        const childrenPropertyName = childrenProperty.name;
                        childrenProperty =
                            ts.updatePropertyAssignment(childrenProperty, childrenPropertyName, ts.factory.createArrayLiteralExpression([...newArrayValues]));
                        existingProperties
                            .splice(index, 1, childrenProperty);
                    }
                    return ts.updateObjectLiteral(currentNode, existingProperties);
                }
                else {
                    return ts.visitEachChild(node, conditionalVisitor, context);
                }
            };
            if (parentRoutePath === undefined) {
                conditionalVisitor = routeArrayVisitor;
            }
            else {
                conditionalVisitor = parentRouteVisitor;
            }
            const visitCondition = (node) => {
                return node.kind === ts.SyntaxKind.VariableDeclaration &&
                    node.name.getText() === routesVariable &&
                    node.type.getText() === "Routes";
            };
            const visitor = this.createVisitor(conditionalVisitor, visitCondition, context);
            context.enableSubstitution(ts.SyntaxKind.ClassDeclaration);
            return ts.visitNode(rootNode, visitor);
        };
        this.targetSource = ts.transform(this.targetSource, [transformer], {
            pretty: true // oh well..
        }).transformed[0];
        this.finalize();
    }
    /**
     * Add named imports from a path/package.
     * @param identifiers Strings to create named import from ("Module" => `import { Module }`)
     * @param modulePath Module specifier - can be path to file or npm package, etc
     */
    requestImport(identifiers, modulePath) {
        const existing = this.requestedImports.find(x => x.from === modulePath);
        if (!existing) {
            // new imports, check if already exists in file
            this.requestedImports.push({
                from: modulePath, imports: identifiers,
                edit: this.importsMeta.modulePaths.indexOf(modulePath) !== -1
            });
        }
        else {
            const newNamedImports = identifiers.filter(x => existing.imports.indexOf(x) === -1);
            existing.imports.push(...newNamedImports);
        }
    }
    /** Add `import` statements not previously found in the file  */
    addNewFileImports() {
        const newImports = this.requestedImports.filter(x => !x.edit);
        if (!newImports.length) {
            return;
        }
        const newStatements = ts.factory.createNodeArray([
            ...this.targetSource.statements.slice(0, this.importsMeta.lastIndex),
            ...newImports.map(x => TypeScriptUtils_1.TypeScriptUtils.createIdentifierImport(x.imports, x.from)),
            ...this.targetSource.statements.slice(this.importsMeta.lastIndex)
        ]);
        newImports.forEach(x => this.createdStringLiterals.push(x.from));
        this.targetSource = ts.factory.updateSourceFile(this.targetSource, newStatements);
    }
    //#endregion ts.TransformerFactory
    //#region Formatting
    /** Format a TS source file, very TBD */
    formatFile(filePath) {
        // formatting via LanguageService https://github.com/Microsoft/TypeScript/wiki/Using-the-Compiler-API
        // https://github.com/Microsoft/TypeScript/issues/1651
        let text = this.fileSystem.readFile(filePath);
        // create the language service files
        const services = ts.createLanguageService(this.getLanguageHost(filePath), ts.createDocumentRegistry());
        this.readFormatConfigs();
        const textChanges = services.getFormattingEditsForDocument(filePath, this.getFormattingOptions());
        text = this.applyChanges(text, textChanges);
        if (this.formatOptions.singleQuotes) {
            for (const str of this.createdStringLiterals) {
                // there shouldn't be duplicate strings of these
                text = text.replace(`"${str}"`, `'${str}'`);
            }
        }
        this.fileSystem.writeFile(filePath, text);
    }
    /**  Try and parse formatting from project `.editorconfig` / `tslint.json` */
    readFormatConfigs() {
        if (this.fileSystem.fileExists(".editorconfig")) {
            // very basic parsing support
            const text = this.fileSystem.readFile(".editorconfig", "utf-8");
            const options = text
                .replace(/\s*[#;].*([\r\n])/g, "$1") //remove comments
                .replace(/\[(?!\*\]|\*.ts).+\][^\[]+/g, "") // leave [*]/[*.ts] sections
                .split(/\r\n|\r|\n/)
                .reduce((obj, x) => {
                if (x.indexOf("=") !== -1) {
                    const pair = x.split("=");
                    obj[pair[0].trim()] = pair[1].trim();
                }
                return obj;
            }, {});
            this.formatOptions.spaces = options["indent_style"] === "space";
            if (options["indent_size"]) {
                this.formatOptions.indentSize = parseInt(options["indent_size"], 10) || this.formatOptions.indentSize;
            }
            if (options["quote_type"]) {
                this.formatOptions.singleQuotes = options["quote_type"] === "single";
            }
        }
        if (this.fileSystem.fileExists("tslint.json")) {
            // tslint prio - overrides other settings
            const options = JSON.parse(this.fileSystem.readFile("tslint.json", "utf-8"));
            if (options.rules && options.rules.indent && options.rules.indent[0]) {
                this.formatOptions.spaces = options.rules.indent[1] === "spaces";
                if (options.rules.indent[2]) {
                    this.formatOptions.indentSize = parseInt(options.rules.indent[2], 10);
                }
            }
            if (options.rules && options.rules.quotemark && options.rules.quotemark[0]) {
                this.formatOptions.singleQuotes = options.rules.quotemark.indexOf("single") !== -1;
            }
        }
    }
    /**
     * Apply formatting changes (position based) in reverse
     * from https://github.com/Microsoft/TypeScript/issues/1651#issuecomment-69877863
     */
    applyChanges(orig, changes) {
        let result = orig;
        for (let i = changes.length - 1; i >= 0; i--) {
            const change = changes[i];
            const head = result.slice(0, change.span.start);
            const tail = result.slice(change.span.start + change.span.length);
            result = head + change.newText + tail;
        }
        return result;
    }
    /** Return source file formatting options */
    getFormattingOptions() {
        const formatOptions = {
            // tslint:disable:object-literal-sort-keys
            indentSize: this.formatOptions.indentSize,
            tabSize: 4,
            newLineCharacter: ts.sys.newLine,
            convertTabsToSpaces: this.formatOptions.spaces,
            indentStyle: ts.IndentStyle.Smart,
            insertSpaceAfterCommaDelimiter: true,
            insertSpaceAfterSemicolonInForStatements: true,
            insertSpaceBeforeAndAfterBinaryOperators: true,
            insertSpaceAfterKeywordsInControlFlowStatements: true,
            insertSpaceAfterTypeAssertion: true
            // tslint:enable:object-literal-sort-keys
        };
        return formatOptions;
    }
    /** Get language service host, sloppily */
    getLanguageHost(filePath) {
        const files = {};
        files[filePath] = { version: 0 };
        // create the language service host to allow the LS to communicate with the host
        const servicesHost = {
            getCompilationSettings: () => ({}),
            getScriptFileNames: () => Object.keys(files),
            getScriptVersion: fileName => files[fileName] && files[fileName].version.toString(),
            getScriptSnapshot: fileName => {
                if (!this.fileSystem.fileExists(fileName)) {
                    return undefined;
                }
                return ts.ScriptSnapshot.fromString(this.fileSystem.readFile(fileName));
            },
            getCurrentDirectory: () => process.cwd(),
            getDefaultLibFileName: options => ts.getDefaultLibFilePath(options),
            readDirectory: ts.sys.readDirectory,
            readFile: ts.sys.readFile,
            fileExists: ts.sys.fileExists
        };
        return servicesHost;
    }
    //#endregion Formatting
    /** Convert a string or string array union to array. Splits strings as comma delimited */
    asArray(value, variables) {
        let result = [];
        if (value) {
            result = typeof value === "string" ? value.split(/\s*,\s*/) : value;
            result = result.map(x => Util_1.Util.applyConfigTransformation(x, variables));
        }
        return result;
    }
    createVisitor(conditionalVisitor, visitCondition, nodeContext) {
        return function visitor(node) {
            if (visitCondition(node)) {
                node = ts.visitEachChild(node, conditionalVisitor, nodeContext);
            }
            else {
                node = ts.visitEachChild(node, visitor, nodeContext);
            }
            return node;
        };
    }
    createRouteEntry(linkPath, className, linkText) {
        const routePath = ts.factory.createPropertyAssignment("path", ts.factory.createStringLiteral(linkPath));
        const routeComponent = ts.factory.createPropertyAssignment("component", ts.factory.createIdentifier(className));
        const routeDataInner = ts.factory.createPropertyAssignment("text", ts.factory.createStringLiteral(linkText));
        const routeData = ts.factory.createPropertyAssignment("data", ts.factory.createObjectLiteralExpression([routeDataInner]));
        return ts.factory.createObjectLiteralExpression([routePath, routeComponent, routeData]);
    }
}
exports.TypeScriptFileUpdate = TypeScriptFileUpdate;
