import * as ts from "typescript";
export declare class TypeScriptUtils {
    static newLinePlaceHolder: string;
    /**
     * Create a node for named import (like `import { ${className} } from "${filePath}"`)
     * @param identifierName Name of the identifier (class, variable)
     * @param importPath Path to import from
     */
    static createIdentifierImport(identifierNames: string[], importPath: string): ts.ImportDeclaration;
    /**
     * Creates a `ts.Expression` for an identifier with optional method call
     * @param x Identifier text
     * @param call Method to call, creating `x.call()`
     */
    static createIdentifier(x: string, call?: string): ts.CallExpression | ts.Identifier;
    /**
     * Checks based on https://github.com/Microsoft/TypeScript/wiki/Using-the-Compiler-API#using-the-type-checker
     * @param nodes Source nodes to iterate
     */
    static getClassName(nodes: ts.Node[]): string;
    /** True if this is visible outside this file, false otherwise */
    static isNodeExported(node: ts.Node): boolean;
    /**
     * Returns node identifier name. Either direct `ts.Identifier` equivalent or simple `ts.CallExpression` supported.
     * Calls with single property access will return the first identifier name (eg. `returnText.propCall()`)
     * @param x Node to extract identifier text from.
     */
    static getIdentifierName(x: ts.Node): string;
    /**
     * Returns an source file, adds new line placeholders as the TS parser won't add `SyntaxKind.NewLineTrivia` to the AST.
     * @param filePath Path of file to read
     */
    static getFileSource(filePath: string): ts.SourceFile;
    /**
     * Prints source, removes new line placeholders and saves the output in a target file
     * @param filePath File path
     * @param source Source AST to print
     */
    static saveFile(filePath: string, source: ts.SourceFile): void;
}
