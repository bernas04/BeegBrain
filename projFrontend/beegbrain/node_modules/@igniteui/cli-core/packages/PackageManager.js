"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.PackageManager = void 0;
const child_process_1 = require("child_process");
const path = require("path");
const types_1 = require("../types");
const util_1 = require("../util");
const componentsConfig = require("./components");
class PackageManager {
    static get fs() {
        return util_1.App.container.get(types_1.FS_TOKEN);
    }
    static get jsonPath() {
        return path.join(process.cwd(), "package.json");
    }
    /**
     * Specific for Ignite UI packages handling:
     *
     * Checks if a full version is required, if there's a user for the ProGet registry
     * and swaps the OSS package for the full version.
     * @param installNow Allow the check to also try installing required Ignite UI package
     */
    static ensureIgniteUISource(installNow = false, templateManager, verbose = false) {
        return __awaiter(this, void 0, void 0, function* () {
            const config = util_1.ProjectConfig.localConfig();
            const fullComponents = config.project.components.filter(x => {
                return componentsConfig.full.indexOf(x) !== -1 || componentsConfig.dv.indexOf(x) !== -1;
            });
            if (!(fullComponents.length && this.isOSSPackage(config.project.igniteuiSource))) {
                //no upgrade required
                return;
            }
            if (installNow) {
                const ossVersion = this.getPackageJSON().dependencies[this.ossPackage];
                const version = ossVersion ? `@"${ossVersion}"` : "";
                const errorMsg = "Something went wrong, " +
                    "please follow the steps in this guide: https://www.igniteui.com/help/using-ignite-ui-npm-packages";
                // fallback to @latest, in case when igniteui-full does not have a matching version to ossVersion
                // ex: "ignite-ui": "^21.1.13" BUT  --> ignite-ui-full": "^21.1.11" (no 21.1.13 released).
                // TODO: update temp fix - only working in 21.1.11 without errors
                // match the version if possible, then fallback to "@latest" instead of "@21.1.11"
                if (this.ensureRegistryUser(config, errorMsg) && this.addPackage(this.fullPackage + version, verbose) ||
                    (this.ensureRegistryUser(config, errorMsg) && this.addPackage(this.fullPackage + "@21.1.11", verbose))) {
                    if (ossVersion) {
                        // TODO: Check if OSS package uninstalled successfully?
                        this.removePackage(this.ossPackage, verbose);
                    }
                    config.project.igniteuiSource = `./node_modules/${this.fullPackage}/en`;
                    util_1.ProjectConfig.setConfig(config);
                    if (!config.project.isBundle) {
                        // TODO make param?
                        const projectLibrary = templateManager.getProjectLibrary(config.project.framework, config.project.projectType);
                        if (projectLibrary) {
                            // TODO multiple projects?
                            let project;
                            if (!config.project.projectTemplate) {
                                // in case project template is missing from the config we provide backward.
                                project = projectLibrary.getProject(projectLibrary.projectIds[0]);
                            }
                            else {
                                project = projectLibrary.getProject(config.project.projectTemplate);
                            }
                            yield project.upgradeIgniteUIPackages(process.cwd(), `./node_modules/${this.fullPackage}/en`);
                        }
                    }
                }
                else {
                    util_1.Util.log("Something went wrong with upgrading Ignite UI to the full version. " +
                        `As a result only views using OSS components will run correctly.`, "yellow");
                    util_1.Util.log("Please visit https://www.igniteui.com/help/using-ignite-ui-npm-packages " +
                        `for instructions on how to install the full package.`, "yellow");
                }
            }
            else {
                util_1.Util.log("Template(s) that require the full version of Ignite UI found in the project. " +
                    "You might be prompted for credentials on build to install it.", "yellow");
            }
        });
    }
    static installPackages(verbose = false) {
        return __awaiter(this, void 0, void 0, function* () {
            const config = util_1.ProjectConfig.localConfig();
            if (!config.packagesInstalled) {
                let command;
                let managerCommand;
                managerCommand = this.getManager();
                switch (managerCommand) {
                    case "npm":
                    /* passes through */
                    default:
                        command = `${managerCommand} install --quiet`;
                        break;
                }
                yield this.flushQueue(false);
                util_1.Util.log(`Installing ${managerCommand} packages`);
                try {
                    // inherit the parent process' stdin so we can catch if an attempt to interrupt the process is made
                    // ignore stdout and stderr as they will output unnecessary text onto the console
                    util_1.Util.execSync(command, { stdio: ["inherit"], killSignal: "SIGINT" });
                    util_1.Util.log(`Packages installed successfully`);
                }
                catch (error) {
                    // ^C (SIGINT) produces status:3221225786 https://github.com/sass/node-sass/issues/1283#issuecomment-169450661
                    if (error.status === 3221225786 || error.status > 128) {
                        // drop process on user interrupt
                        process.exit();
                        return; // just for tests
                    }
                    util_1.Util.log(`Error installing ${managerCommand} packages.`);
                    if (verbose) {
                        util_1.Util.log(error.message);
                    }
                }
                config.packagesInstalled = true;
                util_1.ProjectConfig.setConfig(config);
            }
        });
    }
    static removePackage(packageName, verbose = false) {
        let command;
        const managerCommand = this.getManager();
        switch (managerCommand) {
            case "npm":
            /* passes through */
            default:
                command = `${managerCommand} uninstall ${packageName} --quiet --save`;
                break;
        }
        try {
            // tslint:disable-next-line:object-literal-sort-keys
            util_1.Util.execSync(command, { stdio: "pipe", encoding: "utf8" });
        }
        catch (error) {
            util_1.Util.log(`Error uninstalling package ${packageName} with ${managerCommand}`);
            if (verbose) {
                util_1.Util.log(error.message);
            }
            return false;
        }
        util_1.Util.log(`Package ${packageName} uninstalled successfully`);
        return true;
    }
    static addPackage(packageName, verbose = false) {
        const managerCommand = this.getManager();
        const command = this.getInstallCommand(managerCommand, packageName);
        try {
            // tslint:disable-next-line:object-literal-sort-keys
            util_1.Util.execSync(command, { stdio: "pipe", encoding: "utf8" });
        }
        catch (error) {
            util_1.Util.log(`Error installing package ${packageName} with ${managerCommand}`);
            if (verbose) {
                util_1.Util.log(error.message);
            }
            return false;
        }
        util_1.Util.log(`Package ${packageName} installed successfully`);
        return true;
    }
    static queuePackage(packageName, verbose = false) {
        return __awaiter(this, void 0, void 0, function* () {
            const command = this.getInstallCommand(this.getManager(), packageName).replace("--save", "--no-save");
            const [packName, version] = packageName.split(/@(?=[^\/]+$)/);
            const packageJSON = this.getPackageJSON();
            if (!packageJSON.dependencies) {
                packageJSON.dependencies = {};
            }
            if (packageJSON.dependencies[packName] || this.installQueue.find(x => x["packageName"] === packName)) {
                return;
            }
            packageJSON.dependencies[packName] = version;
            this.fs.writeFile(this.jsonPath, util_1.Util.formatPackageJson(packageJSON));
            // D.P. Concurrent install runs should be supported
            // https://github.com/npm/npm/issues/5948
            // https://github.com/npm/npm/issues/2500
            const task = new Promise((resolve, reject) => {
                const child = (0, child_process_1.exec)(command, {}, (error, stdout, stderr) => {
                    resolve({ packageName, error, stdout, stderr });
                });
            });
            task["packageName"] = packName;
            this.installQueue.push(task);
        });
    }
    /** Waits for queued installs to finish, optionally log results and clear queue */
    static flushQueue(logSuccess, verbose = false) {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.installQueue.length) {
                util_1.Util.log(`Waiting for additional packages to install`);
                const results = yield Promise.all(this.installQueue);
                for (const res of results) {
                    if (res.error) {
                        util_1.Util.log(`Error installing package ${res.packageName}`);
                        if (verbose) {
                            util_1.Util.log(res.stderr.toString());
                        }
                    }
                    else if (logSuccess) {
                        util_1.Util.log(`Package ${res.packageName} installed successfully`);
                    }
                }
                this.installQueue = [];
            }
        });
    }
    static ensureRegistryUser(config, message) {
        const fullPackageRegistry = config.igPackageRegistry;
        try {
            // tslint:disable-next-line:object-literal-sort-keys
            util_1.Util.execSync(`npm whoami --registry=${fullPackageRegistry}`, { stdio: "pipe", encoding: "utf8" });
        }
        catch (error) {
            // try registering the user:
            util_1.Util.log("The project you've created requires the full version of Ignite UI from Infragistics private feed.", "gray");
            util_1.Util.log("We are initiating the login process for you. This will be required only once per environment.", "gray");
            util_1.Util.log(`Adding a registry user account for ${fullPackageRegistry}`, "yellow");
            util_1.Util.log(`Use your Infragistics account credentials. "@" is not supported, ` +
                `use "!!", so "username@infragistics.com" should be entered as "username!!infragistics.com"`, "yellow");
            // TODO: Delete this
            // fix for the stdin steam when using inquirer/readline
            // add isTTY check for CI
            if (process.stdin.isTTY) {
                process.stdin.setRawMode(true);
            }
            const cmd = /^win/.test(process.platform) ? "npm.cmd" : "npm"; //https://github.com/nodejs/node/issues/3675
            const login = (0, child_process_1.spawnSync)(cmd, ["adduser", `--registry=${fullPackageRegistry}`, `--scope=@infragistics`, `--always-auth`], { stdio: "inherit" });
            if ((login === null || login === void 0 ? void 0 : login.status) === 0) {
                //make sure scope is configured:
                try {
                    util_1.Util.execSync(`npm config set @infragistics:registry ${fullPackageRegistry}`);
                    return true;
                }
                catch (error) {
                    return false;
                }
            }
            else {
                util_1.Util.log(message, "red");
                return false;
            }
        }
        return true;
    }
    static getPackageJSON() {
        const content = this.fs.readFile(this.jsonPath);
        return JSON.parse(content);
    }
    static getInstallCommand(managerCommand, packageName) {
        switch (managerCommand) {
            case "npm":
            /* passes through */
            default:
                return `${managerCommand} install ${packageName} --quiet --save`;
        }
    }
    static getManager( /*config:Config*/) {
        //stub to potentially swap out managers
        return "npm";
    }
    static isOSSPackage(original) {
        return original === `./node_modules/${this.ossPackage}`;
    }
}
exports.PackageManager = PackageManager;
PackageManager.ossPackage = "ignite-ui";
PackageManager.fullPackage = "@infragistics/ignite-ui-full";
PackageManager.installQueue = [];
