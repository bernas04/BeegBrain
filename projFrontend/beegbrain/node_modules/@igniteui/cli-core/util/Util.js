"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Util = exports.defaultDelimiters = void 0;
const chalk_1 = require("chalk");
const child_process_1 = require("child_process");
const fs = require("fs");
const glob = require("glob");
const path = require("path");
const through2 = require("through2");
const BaseComponent_1 = require("../templates/BaseComponent");
const types_1 = require("../types");
const App_1 = require("./App");
const GoogleAnalytics_1 = require("./GoogleAnalytics");
const imageExtensions = [".png", ".jpg", ".jpeg", ".gif", ".bmp", ".ico"];
const applyConfig = (configuration) => {
    return through2((data, enc, cb) => {
        cb(null, Buffer.from(Util.applyConfigTransformation(data.toString(), configuration)));
    });
};
const noop = () => through2.obj();
exports.defaultDelimiters = {
    content: {
        start: `$(`,
        end: `)`
    },
    path: {
        start: `__`,
        end: `__`
    }
};
class Util {
    static getCurrentDirectoryBase() {
        return path.basename(process.cwd());
    }
    static directoryExists(dirPath) {
        return App_1.App.container.get(types_1.FS_TOKEN).directoryExists(dirPath);
    }
    static fileExists(filePath) {
        return App_1.App.container.get(types_1.FS_TOKEN).fileExists(filePath);
    }
    static isDirectory(dirPath) {
        return fs.lstatSync(dirPath).isDirectory();
    }
    static isFile(filePath) {
        return fs.lstatSync(filePath).isFile();
    }
    static getDirectoryNames(rootPath) {
        // TODO: add https://github.com/davetemplin/async-file
        let folders = [];
        if (this.directoryExists(rootPath)) {
            folders = fs.readdirSync(rootPath).filter(file => fs.lstatSync(path.join(rootPath, file)).isDirectory());
        }
        return folders;
    }
    static processTemplates(sourcePath, destinationPath, configuration, delimiters, validate = true) {
        return __awaiter(this, void 0, void 0, function* () {
            sourcePath = sourcePath.replace(/\\/g, "/");
            destinationPath = destinationPath.replace(/\\/g, "/");
            if (validate && !this.validateTemplate(sourcePath, destinationPath, configuration, delimiters)) {
                return false;
            }
            return new Promise((resolve, reject) => {
                const filePaths = glob.sync(sourcePath + "/**/*", { nodir: true });
                let fileCount = filePaths.length;
                // if no files should be created, resolve
                if (fileCount === 0) {
                    resolve(false);
                }
                for (const filePath of filePaths) {
                    let targetPath = filePath.replace(sourcePath, destinationPath);
                    targetPath = Util.applyConfigTransformation(targetPath, Util.applyDelimiters(configuration, delimiters.path || exports.defaultDelimiters.path));
                    Util.createDirectory(path.dirname(targetPath));
                    const writeStream = fs.createWriteStream(targetPath);
                    const isImage = imageExtensions.indexOf(path.extname(targetPath)) !== -1;
                    fs.createReadStream(filePath)
                        // for image files, just copy the content
                        .pipe(!isImage ?
                        applyConfig(Util.applyDelimiters(configuration, delimiters.content || exports.defaultDelimiters.content))
                        : noop())
                        .pipe(writeStream);
                    writeStream.on("finish", () => {
                        if (--fileCount === 0) {
                            resolve(true);
                        }
                    });
                }
            });
        });
    }
    static escapeRegExp(str) {
        return str.replace(/[.*+?^${}()|[\]\\]/g, "\\$&"); // $& means the whole matched string
    }
    /**
     * Simple log with optional color.
     * @param message Text to log
     * @param colorKeyword Optional color (CSS keyword like red, green, etc.)
     */
    static log(message, colorKeyword) {
        // tslint:disable:no-console
        if (colorKeyword) {
            const color = chalk_1.default.keyword(colorKeyword);
            console.log(color(message));
        }
        else {
            console.log(message);
        }
        // tslint:enable:no-console
    }
    /**
     * Error log with optional color.
     * @param message Error to log
     * @param colorKeyword Optional color (CSS keyword like red, green, etc.)
     */
    static error(message, colorKeyword) {
        GoogleAnalytics_1.GoogleAnalytics.post({
            t: "screenview",
            cd: `error: ${message}`
        });
        // tslint:disable:no-console
        if (colorKeyword) {
            const color = chalk_1.default.keyword(colorKeyword);
            console.error(color(message));
        }
        else {
            console.error(message);
        }
        // tslint:enable:no-console
    }
    /**
     * Log a warning with optional color.
     * @param message warn to log
     * @param colorKeyword Optional color (CSS keyword like red, green, etc.)
     */
    static warn(message, colorKeyword) {
        // tslint:disable:no-console
        if (colorKeyword) {
            const color = chalk_1.default.keyword(colorKeyword);
            console.warn(color(message));
        }
        else {
            console.warn(message);
        }
        // tslint:enable:no-console
    }
    static greenCheck() {
        if (process.platform.startsWith("win")) {
            return chalk_1.default.green("√");
        }
        else {
            return chalk_1.default.green("✔");
        }
    }
    static formatPackageJson(json, sort = true) {
        if (sort) {
            json.dependencies =
                Object.keys(json.dependencies)
                    .sort()
                    .reduce((result, key) => (result[key] = json.dependencies[key]) && result, {});
        }
        return JSON.stringify(json, null, 2) + "\n";
    }
    static formatAngularJsonOptions(json) {
        return JSON.stringify(json, null, 2) + "\n";
    }
    static version(filePath) {
        const configuration = require(filePath || "../package.json");
        return configuration.version;
    }
    static showVersion(filePath) {
        const logo = fs.readFileSync(filePath);
        logo.toString().split("\n").forEach(line => {
            this.log(line);
        });
        this.log("Ignite UI CLI version: " + this.version());
        this.log("OS: " + this.getOSFriendlyName(process.platform));
    }
    static getOSFriendlyName(platform) {
        let os = "";
        switch (platform) {
            case "win32":
                os = "Windows";
                break;
            case "darwin":
                os = "Mac OS";
                break;
            case "freebsd":
                os = "FreeBSD";
                break;
            default:
                os = "Unknown OS";
                break;
        }
        return os;
    }
    /**
     * lower-dashed string
     */
    static lowerDashed(text) {
        return text.replace(/\s+/g, "-").toLowerCase();
    }
    /**
     * Checks if a giver string consists of alphanumeric characters, dashes and spaces only
     * and also starts with a letter.
     * @param name Text to check
     */
    static isAlphanumericExt(name) {
        return /^[\sa-zA-Z][\w\s\-]*$/.test(name);
    }
    /**
     * Separate provided name to words on each space and/or dash and capitalize first letter of each
     * resulting word.
     * @param name Text to convert to proper class name
     */
    static className(name) {
        return name.replace(/\w[^-\s]*/g, txt => txt.charAt(0).toUpperCase() + txt.substr(1)).replace(/[-\s]/g, "");
    }
    /**
     * Simple object merge - deep nested objects and arrays (of primitive values only)
     * @param target Object to merge values into
     * @param source Object to merge values from
     */
    static merge(target, source) {
        if (!source) {
            return target;
        }
        for (const key of Object.keys(source)) {
            const sourceKeyIsArray = Array.isArray(source[key]);
            const targetHasThisKey = target.hasOwnProperty(key);
            if (typeof source[key] === "object" && !sourceKeyIsArray) {
                // object value:
                if (!targetHasThisKey) {
                    target[key] = {};
                }
                this.merge(target[key], source[key]);
            }
            else if (sourceKeyIsArray) {
                //	array value:
                if (targetHasThisKey) {
                    // skip array merge on target type mismatch:
                    if (!Array.isArray(target[key])) {
                        continue;
                    }
                    for (const item of source[key]) {
                        if (target[key].indexOf(item) === -1) {
                            target[key].push(item);
                        }
                    }
                }
                else {
                    target[key] = source[key].slice(0);
                }
            }
            else {
                // primitive value:
                target[key] = source[key];
            }
        }
    }
    /**
     * Execute synchronous command with options
     * @param command Command to be executed
     * @param options Command options
     * @throws {Error} On timeout or non-zero exit code. Error has 'status', 'signal', 'output', 'stdout', 'stderr'
     */
    static execSync(command, options) {
        try {
            return (0, child_process_1.execSync)(command, options);
        }
        catch (error) {
            // execSync may throw an error during process interruption
            // if this happens - stderr will end with "^C" which was appended in the checkExecSyncError function
            // this means that a SIGINT was attempted and failed
            // npm may be involved in this as it works just fine with any other node process
            if (error.stderr && error.stderr.toString().endsWith() === "^C") {
                return process.exit();
            }
            // if SIGINT killed the process with no errors
            // 3221225786 - cmd- Ctrl+C
            // 128 - bash - invalid argument to exit
            // 130 - bash - Ctrl+C
            // 255 - bash - exit status out of range
            if (error.status === 3221225786 || error.status > 128) {
                return process.exit();
            }
            throw error;
        }
    }
    /**
     * Initialize git for a project, located in the provided directory and commit it.
     * @param parentRoot Parent directory root of the project.
     * @param projectName Project name.
     */
    static gitInit(parentRoot, projectName) {
        try {
            const options = { cwd: path.join(parentRoot, projectName), stdio: [process.stdin, "ignore", "ignore"] };
            Util.execSync("git init", options);
            Util.execSync("git add .", options);
            Util.execSync("git commit -m " + "\"Initial commit for project: " + projectName + "\"", options);
            Util.log(Util.greenCheck() + " Git Initialized and Project '" + projectName + "' Committed");
        }
        catch (error) {
            Util.error("Git initialization failed. Install Git in order to automatically commit the project.", "yellow");
        }
    }
    /**
     * Truncating text to fit console viewPort and appending specified truncate characters at the end
     * to indicate text is truncated.
     * @param text Text to be used.
     * @param limit max viewPort.
     * @param truncateCount How many characters to be replaced at the text end with a specified truncateChar.
     * @param truncateChar Char to use for truncated text.
     */
    static truncate(text, limit, count = 3, truncateChar = ".") {
        //adjust for console characters prior description
        if (text.length > limit) {
            text = text.slice(0, (limit - count)).trim() + truncateChar.repeat(count);
        }
        return text;
    }
    /**
     * to indicate text is truncated.
     * @param text Text to be used.
     * @param startIndex Apply color from this index on.
     */
    static addColor(text, startIndex) {
        const name = text.slice(0, startIndex);
        const separatedDescription = text.slice(startIndex);
        return name + chalk_1.default.gray(`${separatedDescription}`);
    }
    /**
     * Returns a colored text
     */
    static color(text, colorKeyword) {
        const color = chalk_1.default.keyword(colorKeyword);
        return color(text);
    }
    static getAvailableName(defaultName, isApp, framework, projectType) {
        const baseLength = defaultName.length;
        let specificPath = "";
        if (framework === "angular" && projectType === "igx-ts") {
            specificPath = path.join("src", "app");
        }
        else if (framework === "angular" && projectType === "ig-ts") {
            specificPath = path.join("src", "app", "components");
        }
        else if (framework === "react" && projectType === "es6") {
            specificPath = path.join("src", "components");
        }
        else if (framework === "react" && projectType === "igr-es6") {
            specificPath = path.join("src", "views");
        }
        else if (framework === "webcomponents" && projectType === "igc-ts") {
            specificPath = path.join("src", "app");
        }
        if (isApp) {
            while (Util.directoryExists(path.join(App_1.App.workDir, defaultName))) {
                defaultName = Util.incrementName(defaultName, baseLength);
            }
        }
        else {
            while (Util.directoryExists(path.join(App_1.App.workDir, specificPath, Util.lowerDashed(defaultName)))) {
                defaultName = Util.incrementName(defaultName, baseLength);
            }
        }
        return defaultName;
    }
    /**
     * Creates all folders in a given absolute path. Starts from cwd
     * @param targetDir Absolute path to folder to create
     * @throws Throws on `EACCES`, `EISDIR`
     */
    static createDirectory(targetDir) {
        // start from current
        let curDir = process.cwd();
        if (path.isAbsolute(targetDir)) {
            // strip target to relative
            targetDir = path.relative(curDir, targetDir);
        }
        // split target into parts and go through
        targetDir.split(path.sep).forEach(childDir => {
            curDir = path.resolve(curDir, childDir);
            try {
                fs.mkdirSync(curDir);
            }
            catch (err) {
                // reuse catch rather than another one from `this.directoryExists`
                if (err.code === "EEXIST") {
                    return;
                }
                this.error(`Failed to create ${curDir}`, "red");
                this.error(err.message, "red");
                throw err;
            }
        });
    }
    /**
     * Extracts the name (last part) from a path and trims.
     * @param fileName Path-like name, e.g. /path/to/my component
     */
    static nameFromPath(fileName) {
        const parts = path.parse(fileName);
        const name = parts.name + parts.ext;
        // trim name itself to avoid creating awkward component names
        return name.trim();
    }
    static camelCase(str) {
        if (!str) {
            return null;
        }
        const result = this.className(str);
        return result[0].toLowerCase() + result.substring(1, result.length);
    }
    /**
     * Generate relative path from target file to another
     * Adds "./" to avoid node module resolution conflicts
     * @param targetPath Target file (root path)
     * @param filePath File to generate relative path to
     * @param posix Require path in posix style (/-separated)
     * @param removeExt Strip file extension
     */
    static relativePath(targetPath, filePath, posix, removeExt = true) {
        if (!targetPath.endsWith(path.win32.sep) && !targetPath.endsWith(path.posix.sep)) {
            // path.relative splits by fragments, must be dirname w/ trailing to work both down and up
            targetPath = path.win32.dirname(targetPath) + path.sep;
        }
        // use win32 api as it handles both formats
        let relativePath = path.win32.relative(targetPath, filePath);
        if (removeExt) {
            relativePath = relativePath.replace(path.win32.extname(relativePath), "");
        }
        if (posix) {
            relativePath = path.posix.join(...relativePath.split(path.win32.sep));
            relativePath = relativePath.startsWith(".") ? relativePath : "./" + relativePath;
        }
        else {
            relativePath = path.win32.join(...relativePath.split(path.win32.sep));
            relativePath = relativePath.startsWith(".") ? relativePath : ".\\" + relativePath;
        }
        return relativePath;
    }
    static formatChoices(items, padding = 3) {
        const choiceItems = [];
        const leftPadding = 2;
        const rightPadding = 1;
        const maxNameLength = Math.max(...items.map(x => x.name.length)) + padding;
        const targetNameLength = Math.max(18, maxNameLength);
        let description;
        for (const item of items) {
            const choiceItem = {
                name: "",
                short: item.name,
                value: item.name
            };
            choiceItem.name = item.name;
            if (item instanceof BaseComponent_1.BaseComponent && item.templates.length <= 1) {
                description = item.templates[0].description || "";
            }
            else {
                description = item.description || "";
            }
            if (description !== "") {
                choiceItem.name = item.name + Util.addColor(".".repeat(targetNameLength - item.name.length), 0);
                const max = process.stdout.columns - targetNameLength - leftPadding - rightPadding;
                description = Util.truncate(description, max, 3, ".");
                description = Util.addColor(description, 0);
                choiceItem.name += description;
            }
            choiceItems.push(choiceItem);
        }
        return choiceItems;
    }
    static applyDelimiters(config, delimiter) {
        const obj = {};
        for (const key of Object.keys(config)) {
            obj[`${delimiter.start}${key}${delimiter.end}`] = config[key];
        }
        return obj;
    }
    static incrementName(name, baseLength) {
        const text = name.slice(0, baseLength);
        const number = parseInt(name.slice(baseLength + 1), 10) || 0;
        return `${text} ${number + 1}`;
    }
    static propertyByPath(object, propPath) {
        if (!propPath) {
            return object;
        }
        const pathParts = propPath.split(".");
        const currentProp = pathParts.shift();
        if (currentProp in object) {
            return this.propertyByPath(object[currentProp], pathParts.join("."));
        }
    }
    static validateTemplate(sourcePath, destinationPath, configuration, delimiters) {
        sourcePath = sourcePath.replace(/\\/g, "/");
        destinationPath = destinationPath.replace(/\\/g, "/");
        let paths = glob.sync(sourcePath + "/**/*", { nodir: true });
        // TODO: D.P Temporary ignoring asset files
        const ignorePaths = glob.sync(sourcePath + "/**/+(assets|data)/**/*", { nodir: true });
        paths = paths.filter(x => ignorePaths.indexOf(x) === -1);
        for (let filePath of paths) {
            filePath = filePath.replace(sourcePath, destinationPath);
            filePath = Util.applyConfigTransformation(filePath, Util.applyDelimiters(configuration, delimiters.path || exports.defaultDelimiters.path));
            if (fs.existsSync(filePath)) {
                this.error(path.relative(process.cwd(), filePath) + " already exists!", "red");
                return false;
            }
        }
        return true;
    }
}
exports.Util = Util;
Util.applyConfigTransformation = (data, configuration) => {
    let key;
    // tslint:disable-next-line:forin
    for (key in configuration) {
        data = data.replace(new RegExp(Util.escapeRegExp(key), "g"), configuration[key]);
    }
    return data;
};
