"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.component = exports.singleComponent = void 0;
const core_1 = require("@angular-devkit/core");
const schematics_1 = require("@angular-devkit/schematics");
const tasks_1 = require("@angular-devkit/schematics/tasks");
const cli_core_1 = require("@igniteui/cli-core");
const SchematicsPromptSession_1 = require("../prompt/SchematicsPromptSession");
const SchematicsTemplateManager_1 = require("../SchematicsTemplateManager");
const NgFileSystem_1 = require("../utils/NgFileSystem");
function registerInProject(templateOpts, skipRoute, modulePath) {
    return (_host, _context) => {
        templateOpts.templateInst.registerInProject("", templateOpts.name, { skipRoute, modulePath });
    };
}
function getMissingPackages(templateOpts, packages) {
    return (_host, _context) => {
        for (const packageName of templateOpts.templateInst.packages) {
            const packageMatch = packageName.split(/@(?=[^\/]+$)/);
            packages.set(packageMatch[0], packageMatch[1] || "*");
        }
    };
}
function updatePackageJSON(installContext) {
    return (host, _context) => {
        if (installContext.packages.size) {
            const packageJSON = JSON.parse((host.read("package.json") || "").toString());
            installContext.packages.forEach((version, name) => {
                if (!packageJSON.dependencies[name]) {
                    packageJSON.dependencies[name] = version;
                    installContext.shouldInstall = true;
                }
            });
            if (installContext.shouldInstall) {
                host.overwrite("package.json", JSON.stringify(packageJSON, null, 2));
            }
        }
    };
}
function addComponent(options, skipRoute = false, modulePath) {
    return (tree, _context) => __awaiter(this, void 0, void 0, function* () {
        (0, NgFileSystem_1.setVirtual)(tree);
        const config = options.templateInst.generateConfig(options.name, {});
        return (0, schematics_1.chain)([...options.templateInst.templatePaths.map(templatePath => (0, schematics_1.mergeWith)((0, schematics_1.apply)((0, schematics_1.url)(cli_core_1.Util.relativePath(__filename, templatePath, true)), [
                (0, schematics_1.template)(config)
            ]), schematics_1.MergeStrategy.Overwrite)), registerInProject(options, skipRoute, modulePath)]);
    });
}
function singleComponent(templateOptions, skipRoute) {
    return (_tree, _context) => __awaiter(this, void 0, void 0, function* () {
        const packages = new Map();
        return (0, schematics_1.chain)([
            addComponent(templateOptions, skipRoute),
            getMissingPackages(templateOptions, packages),
            updatePackageJSON({ packages })
        ]);
    });
}
exports.singleComponent = singleComponent;
function component(options) {
    return (tree, context) => __awaiter(this, void 0, void 0, function* () {
        cli_core_1.App.initialize("angular-cli");
        cli_core_1.GoogleAnalytics.post({
            t: "screenview",
            cd: "Add"
        });
        const addedComponents = [];
        const templateManager = new SchematicsTemplateManager_1.SchematicsTemplateManager();
        const projLib = templateManager.getProjectLibrary("angular", "igx-ts");
        /**
         * MDNT
         * Once inside the chooseActionLoop, the projLibrary cannot properly get
         * its templates, as it seems it cannot read outside of the current context
         * Since the projLib caches its templates, we make the initial call here so we have
         * access to the in the following steps.
         */
        const properties = {
            component: projLib.components,
            custom: projLib.getCustomTemplates()
        };
        let prompt;
        if (!options.template || !options.name) {
            prompt = new SchematicsPromptSession_1.SchematicsPromptSession(templateManager);
            prompt.setContext(context, tree, options.name);
            (0, NgFileSystem_1.setVirtual)(tree);
            yield prompt.chooseActionLoop(projLib);
        }
        else {
            if (!projLib.hasTemplate(options.template)) {
                throw new schematics_1.SchematicsException(`template with id '${options.template}' not found`);
            }
            options.templateInst = projLib.getTemplateById(options.template);
            addedComponents.push(options);
            const config = cli_core_1.ProjectConfig.getConfig();
            const selectedTemplate = options.templateInst;
            cli_core_1.GoogleAnalytics.post({
                t: "event",
                ec: "$ng add",
                ea: `template id: ${options.template}; file name: ${options.name}`,
                cd1: selectedTemplate.framework,
                cd2: selectedTemplate.projectType,
                cd5: selectedTemplate.controlGroup,
                cd7: selectedTemplate.id,
                cd8: selectedTemplate.name,
                cd11: !!config.skipGit,
                cd14: config.project.theme
            });
        }
        const installContext = {
            packages: new Map(),
            shouldInstall: false
        };
        return (0, schematics_1.chain)([
            ...addedComponents.map(templateOpts => {
                context.logger.info(`Generating ${templateOpts.templateInst.name} with name: ${templateOpts.name}`);
                return (0, schematics_1.chain)([
                    (_tree, _context) => {
                        return cli_core_1.App.container.get(cli_core_1.FS_TYPE_TOKEN) === cli_core_1.FsTypes.virtual ?
                            _tree :
                            addComponent(templateOpts, options.skipRoute || false, options.module);
                    },
                    getMissingPackages(templateOpts, installContext.packages)
                ]);
            }),
            updatePackageJSON(installContext),
            (_host, _context) => {
                // if called w/ command line arguments, check if dependencies are added and add install task.
                if (!prompt) {
                    if (installContext.shouldInstall) {
                        _context.addTask(new tasks_1.NodePackageInstallTask());
                        return;
                    }
                    return;
                }
                else if (_host.actions.find(x => x.path === (0, core_1.normalize)("/package.json") && x.kind === "o")) {
                    // prompt added components with extra packages
                    installContext.shouldInstall = true;
                }
                _context.addTask(new tasks_1.RunSchematicTask("start", {}), installContext.shouldInstall ? [_context.addTask(new tasks_1.NodePackageInstallTask())] : []);
            }
        ]);
    });
}
exports.component = component;
